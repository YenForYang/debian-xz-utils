\section{liblzma/api/lzma/index\+\_\+hash.h File Reference}
\label{index__hash_8h}\index{liblzma/api/lzma/index\+\_\+hash.\+h@{liblzma/api/lzma/index\+\_\+hash.\+h}}


Validate Index by using a hash function.  


\subsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
typedef struct \textbf{ lzma\+\_\+index\+\_\+hash\+\_\+s} \textbf{ lzma\+\_\+index\+\_\+hash}
\begin{DoxyCompactList}\small\item\em Opaque data type to hold the Index hash. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\textbf{ lzma\+\_\+index\+\_\+hash} $\ast$ \textbf{ lzma\+\_\+index\+\_\+hash\+\_\+init} (\textbf{ lzma\+\_\+index\+\_\+hash} $\ast$index\+\_\+hash, const \textbf{ lzma\+\_\+allocator} $\ast$allocator) lzma\+\_\+nothrow lzma\+\_\+attr\+\_\+warn\+\_\+unused\+\_\+result
\begin{DoxyCompactList}\small\item\em Allocate and initialize a new lzma\+\_\+index\+\_\+hash structure. \end{DoxyCompactList}\item 
void \textbf{ lzma\+\_\+index\+\_\+hash\+\_\+end} (\textbf{ lzma\+\_\+index\+\_\+hash} $\ast$index\+\_\+hash, const \textbf{ lzma\+\_\+allocator} $\ast$allocator) lzma\+\_\+nothrow
\begin{DoxyCompactList}\small\item\em Deallocate lzma\+\_\+index\+\_\+hash structure. \end{DoxyCompactList}\item 
\textbf{ lzma\+\_\+ret} \textbf{ lzma\+\_\+index\+\_\+hash\+\_\+append} (\textbf{ lzma\+\_\+index\+\_\+hash} $\ast$index\+\_\+hash, \textbf{ lzma\+\_\+vli} unpadded\+\_\+size, \textbf{ lzma\+\_\+vli} uncompressed\+\_\+size) lzma\+\_\+nothrow lzma\+\_\+attr\+\_\+warn\+\_\+unused\+\_\+result
\begin{DoxyCompactList}\small\item\em Add a new Record to an Index hash. \end{DoxyCompactList}\item 
\textbf{ lzma\+\_\+ret} \textbf{ lzma\+\_\+index\+\_\+hash\+\_\+decode} (\textbf{ lzma\+\_\+index\+\_\+hash} $\ast$index\+\_\+hash, const uint8\+\_\+t $\ast$in, size\+\_\+t $\ast$in\+\_\+pos, size\+\_\+t in\+\_\+size) lzma\+\_\+nothrow lzma\+\_\+attr\+\_\+warn\+\_\+unused\+\_\+result
\begin{DoxyCompactList}\small\item\em Decode and validate the Index field. \end{DoxyCompactList}\item 
\textbf{ lzma\+\_\+vli} \textbf{ lzma\+\_\+index\+\_\+hash\+\_\+size} (const \textbf{ lzma\+\_\+index\+\_\+hash} $\ast$index\+\_\+hash) lzma\+\_\+nothrow lzma\+\_\+attr\+\_\+pure
\begin{DoxyCompactList}\small\item\em Get the size of the Index field as bytes. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
Validate Index by using a hash function. 

Hashing makes it possible to use constant amount of memory to validate Index of arbitrary size. 

\subsection{Typedef Documentation}
\mbox{\label{index__hash_8h_a2db9f438838c8ff72a8a6fd3fc856f8c}} 
\index{index\+\_\+hash.\+h@{index\+\_\+hash.\+h}!lzma\+\_\+index\+\_\+hash@{lzma\+\_\+index\+\_\+hash}}
\index{lzma\+\_\+index\+\_\+hash@{lzma\+\_\+index\+\_\+hash}!index\+\_\+hash.\+h@{index\+\_\+hash.\+h}}
\subsubsection{lzma\+\_\+index\+\_\+hash}
{\footnotesize\ttfamily typedef struct \textbf{ lzma\+\_\+index\+\_\+hash\+\_\+s} \textbf{ lzma\+\_\+index\+\_\+hash}}



Opaque data type to hold the Index hash. 



\subsection{Function Documentation}
\mbox{\label{index__hash_8h_a65cfc02de059343f6ecda2b109f78d28}} 
\index{index\+\_\+hash.\+h@{index\+\_\+hash.\+h}!lzma\+\_\+index\+\_\+hash\+\_\+init@{lzma\+\_\+index\+\_\+hash\+\_\+init}}
\index{lzma\+\_\+index\+\_\+hash\+\_\+init@{lzma\+\_\+index\+\_\+hash\+\_\+init}!index\+\_\+hash.\+h@{index\+\_\+hash.\+h}}
\subsubsection{lzma\+\_\+index\+\_\+hash\+\_\+init()}
{\footnotesize\ttfamily \textbf{ lzma\+\_\+index\+\_\+hash}$\ast$ lzma\+\_\+index\+\_\+hash\+\_\+init (\begin{DoxyParamCaption}\item[{\textbf{ lzma\+\_\+index\+\_\+hash} $\ast$}]{index\+\_\+hash,  }\item[{const \textbf{ lzma\+\_\+allocator} $\ast$}]{allocator }\end{DoxyParamCaption})}



Allocate and initialize a new lzma\+\_\+index\+\_\+hash structure. 

If index\+\_\+hash is N\+U\+LL, a new lzma\+\_\+index\+\_\+hash structure is allocated, initialized, and a pointer to it returned. If allocation fails, N\+U\+LL is returned.

If index\+\_\+hash is non-\/\+N\+U\+LL, it is reinitialized and the same pointer returned. In this case, return value cannot be N\+U\+LL or a different pointer than the index\+\_\+hash that was given as an argument. \mbox{\label{index__hash_8h_a7dacb41b9ec1c8df5d33dfdae97743b3}} 
\index{index\+\_\+hash.\+h@{index\+\_\+hash.\+h}!lzma\+\_\+index\+\_\+hash\+\_\+end@{lzma\+\_\+index\+\_\+hash\+\_\+end}}
\index{lzma\+\_\+index\+\_\+hash\+\_\+end@{lzma\+\_\+index\+\_\+hash\+\_\+end}!index\+\_\+hash.\+h@{index\+\_\+hash.\+h}}
\subsubsection{lzma\+\_\+index\+\_\+hash\+\_\+end()}
{\footnotesize\ttfamily void lzma\+\_\+index\+\_\+hash\+\_\+end (\begin{DoxyParamCaption}\item[{\textbf{ lzma\+\_\+index\+\_\+hash} $\ast$}]{index\+\_\+hash,  }\item[{const \textbf{ lzma\+\_\+allocator} $\ast$}]{allocator }\end{DoxyParamCaption})}



Deallocate lzma\+\_\+index\+\_\+hash structure. 

\mbox{\label{index__hash_8h_a2bdbe4f0b5fa2fadb7528447feaaa97f}} 
\index{index\+\_\+hash.\+h@{index\+\_\+hash.\+h}!lzma\+\_\+index\+\_\+hash\+\_\+append@{lzma\+\_\+index\+\_\+hash\+\_\+append}}
\index{lzma\+\_\+index\+\_\+hash\+\_\+append@{lzma\+\_\+index\+\_\+hash\+\_\+append}!index\+\_\+hash.\+h@{index\+\_\+hash.\+h}}
\subsubsection{lzma\+\_\+index\+\_\+hash\+\_\+append()}
{\footnotesize\ttfamily \textbf{ lzma\+\_\+ret} lzma\+\_\+index\+\_\+hash\+\_\+append (\begin{DoxyParamCaption}\item[{\textbf{ lzma\+\_\+index\+\_\+hash} $\ast$}]{index\+\_\+hash,  }\item[{\textbf{ lzma\+\_\+vli}}]{unpadded\+\_\+size,  }\item[{\textbf{ lzma\+\_\+vli}}]{uncompressed\+\_\+size }\end{DoxyParamCaption})}



Add a new Record to an Index hash. 


\begin{DoxyParams}{Parameters}
{\em index} & Pointer to a lzma\+\_\+index\+\_\+hash structure \\
\hline
{\em unpadded\+\_\+size} & Unpadded Size of a Block \\
\hline
{\em uncompressed\+\_\+size} & Uncompressed Size of a Block\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
-\/ L\+Z\+M\+A\+\_\+\+OK
\begin{DoxyItemize}
\item L\+Z\+M\+A\+\_\+\+D\+A\+T\+A\+\_\+\+E\+R\+R\+OR\+: Compressed or uncompressed size of the Stream or size of the Index field would grow too big.
\item L\+Z\+M\+A\+\_\+\+P\+R\+O\+G\+\_\+\+E\+R\+R\+OR\+: Invalid arguments or this function is being used when \doxyref{lzma\+\_\+index\+\_\+hash\+\_\+decode()}{p.}{index__hash_8h_a891eb955284c9117155f92eb0ddba44c} has already been used. 
\end{DoxyItemize}
\end{DoxyReturn}


References hash\+\_\+append(), L\+Z\+M\+A\+\_\+\+P\+R\+O\+G\+\_\+\+E\+R\+R\+OR, L\+Z\+M\+A\+\_\+\+V\+L\+I\+\_\+\+M\+AX, return\+\_\+if\+\_\+error, lzma\+\_\+index\+\_\+hash\+\_\+s\+::uncompressed\+\_\+size, and lzma\+\_\+index\+\_\+hash\+\_\+s\+::unpadded\+\_\+size.

\mbox{\label{index__hash_8h_a891eb955284c9117155f92eb0ddba44c}} 
\index{index\+\_\+hash.\+h@{index\+\_\+hash.\+h}!lzma\+\_\+index\+\_\+hash\+\_\+decode@{lzma\+\_\+index\+\_\+hash\+\_\+decode}}
\index{lzma\+\_\+index\+\_\+hash\+\_\+decode@{lzma\+\_\+index\+\_\+hash\+\_\+decode}!index\+\_\+hash.\+h@{index\+\_\+hash.\+h}}
\subsubsection{lzma\+\_\+index\+\_\+hash\+\_\+decode()}
{\footnotesize\ttfamily \textbf{ lzma\+\_\+ret} lzma\+\_\+index\+\_\+hash\+\_\+decode (\begin{DoxyParamCaption}\item[{\textbf{ lzma\+\_\+index\+\_\+hash} $\ast$}]{index\+\_\+hash,  }\item[{const uint8\+\_\+t $\ast$}]{in,  }\item[{size\+\_\+t $\ast$}]{in\+\_\+pos,  }\item[{size\+\_\+t}]{in\+\_\+size }\end{DoxyParamCaption})}



Decode and validate the Index field. 

After telling the sizes of all Blocks with \doxyref{lzma\+\_\+index\+\_\+hash\+\_\+append()}{p.}{index__hash_8h_a2bdbe4f0b5fa2fadb7528447feaaa97f}, the actual Index field is decoded with this function. Specifically, once decoding of the Index field has been started, no more Records can be added using \doxyref{lzma\+\_\+index\+\_\+hash\+\_\+append()}{p.}{index__hash_8h_a2bdbe4f0b5fa2fadb7528447feaaa97f}.

This function doesn\textquotesingle{}t use \doxyref{lzma\+\_\+stream}{p.}{structlzma__stream} structure to pass the input data. Instead, the input buffer is specified using three arguments. This is because it matches better the internal A\+P\+Is of liblzma.


\begin{DoxyParams}{Parameters}
{\em index\+\_\+hash} & Pointer to a lzma\+\_\+index\+\_\+hash structure \\
\hline
{\em in} & Pointer to the beginning of the input buffer \\
\hline
{\em in\+\_\+pos} & in[$\ast$in\+\_\+pos] is the next byte to process \\
\hline
{\em in\+\_\+size} & in[in\+\_\+size] is the first byte not to process\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
-\/ L\+Z\+M\+A\+\_\+\+OK\+: So far good, but more input is needed.
\begin{DoxyItemize}
\item L\+Z\+M\+A\+\_\+\+S\+T\+R\+E\+A\+M\+\_\+\+E\+ND\+: Index decoded successfully and it matches the Records given with \doxyref{lzma\+\_\+index\+\_\+hash\+\_\+append()}{p.}{index__hash_8h_a2bdbe4f0b5fa2fadb7528447feaaa97f}.
\item L\+Z\+M\+A\+\_\+\+D\+A\+T\+A\+\_\+\+E\+R\+R\+OR\+: Index is corrupt or doesn\textquotesingle{}t match the information given with \doxyref{lzma\+\_\+index\+\_\+hash\+\_\+append()}{p.}{index__hash_8h_a2bdbe4f0b5fa2fadb7528447feaaa97f}.
\item L\+Z\+M\+A\+\_\+\+B\+U\+F\+\_\+\+E\+R\+R\+OR\+: Cannot progress because $\ast$in\+\_\+pos $>$= in\+\_\+size.
\item L\+Z\+M\+A\+\_\+\+P\+R\+O\+G\+\_\+\+E\+R\+R\+OR 
\end{DoxyItemize}
\end{DoxyReturn}


References hash\+\_\+append(), L\+Z\+M\+A\+\_\+\+B\+U\+F\+\_\+\+E\+R\+R\+OR, lzma\+\_\+check\+\_\+finish(), lzma\+\_\+check\+\_\+size(), lzma\+\_\+crc32(), L\+Z\+M\+A\+\_\+\+D\+A\+T\+A\+\_\+\+E\+R\+R\+OR, L\+Z\+M\+A\+\_\+\+OK, L\+Z\+M\+A\+\_\+\+S\+T\+R\+E\+A\+M\+\_\+\+E\+ND, L\+Z\+M\+A\+\_\+\+V\+L\+I\+\_\+C, lzma\+\_\+vli\+\_\+decode(), and return\+\_\+if\+\_\+error.

\mbox{\label{index__hash_8h_a0f8ab3b57b117f9547866156755c917f}} 
\index{index\+\_\+hash.\+h@{index\+\_\+hash.\+h}!lzma\+\_\+index\+\_\+hash\+\_\+size@{lzma\+\_\+index\+\_\+hash\+\_\+size}}
\index{lzma\+\_\+index\+\_\+hash\+\_\+size@{lzma\+\_\+index\+\_\+hash\+\_\+size}!index\+\_\+hash.\+h@{index\+\_\+hash.\+h}}
\subsubsection{lzma\+\_\+index\+\_\+hash\+\_\+size()}
{\footnotesize\ttfamily \textbf{ lzma\+\_\+vli} lzma\+\_\+index\+\_\+hash\+\_\+size (\begin{DoxyParamCaption}\item[{const \textbf{ lzma\+\_\+index\+\_\+hash} $\ast$}]{index\+\_\+hash }\end{DoxyParamCaption})}



Get the size of the Index field as bytes. 

This is needed to verify the Backward Size field in the Stream Footer. 