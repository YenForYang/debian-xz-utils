\section{liblzma/common/block\+\_\+buffer\+\_\+encoder.c File Reference}
\label{block__buffer__encoder_8c}\index{liblzma/common/block\+\_\+buffer\+\_\+encoder.\+c@{liblzma/common/block\+\_\+buffer\+\_\+encoder.\+c}}


Single-\/call .xz Block encoder.  


{\ttfamily \#include \char`\"{}block\+\_\+buffer\+\_\+encoder.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}block\+\_\+encoder.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}filter\+\_\+encoder.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}lzma2\+\_\+encoder.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}check.\+h\char`\"{}}\newline
\subsection*{Macros}
\begin{DoxyCompactItemize}
\item 
\#define \textbf{ H\+E\+A\+D\+E\+R\+S\+\_\+\+B\+O\+U\+ND}
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\label{block__buffer__encoder_8c_a6898d0dc76ff4e030055ce346a6ef57a}} 
static uint64\+\_\+t {\bfseries lzma2\+\_\+bound} (uint64\+\_\+t uncompressed\+\_\+size)
\item 
uint64\+\_\+t \textbf{ lzma\+\_\+block\+\_\+buffer\+\_\+bound64} (uint64\+\_\+t uncompressed\+\_\+size)
\item 
size\+\_\+t \textbf{ lzma\+\_\+block\+\_\+buffer\+\_\+bound} (size\+\_\+t uncompressed\+\_\+size)
\begin{DoxyCompactList}\small\item\em Calculate maximum output size for single-\/call Block encoding. \end{DoxyCompactList}\item 
\mbox{\label{block__buffer__encoder_8c_a5295d468fbf2da3a35f458c90b7966c5}} 
static \textbf{ lzma\+\_\+ret} {\bfseries block\+\_\+encode\+\_\+uncompressed} (\textbf{ lzma\+\_\+block} $\ast$block, const uint8\+\_\+t $\ast$in, size\+\_\+t in\+\_\+size, uint8\+\_\+t $\ast$out, size\+\_\+t $\ast$out\+\_\+pos, size\+\_\+t out\+\_\+size)
\item 
\mbox{\label{block__buffer__encoder_8c_a9c318709429c788b7d46a496bee07793}} 
static \textbf{ lzma\+\_\+ret} {\bfseries block\+\_\+encode\+\_\+normal} (\textbf{ lzma\+\_\+block} $\ast$block, const \textbf{ lzma\+\_\+allocator} $\ast$allocator, const uint8\+\_\+t $\ast$in, size\+\_\+t in\+\_\+size, uint8\+\_\+t $\ast$out, size\+\_\+t $\ast$out\+\_\+pos, size\+\_\+t out\+\_\+size)
\item 
\mbox{\label{block__buffer__encoder_8c_af47a9de6406a0ab2c8eb1f407a61eaae}} 
static \textbf{ lzma\+\_\+ret} {\bfseries block\+\_\+buffer\+\_\+encode} (\textbf{ lzma\+\_\+block} $\ast$block, const \textbf{ lzma\+\_\+allocator} $\ast$allocator, const uint8\+\_\+t $\ast$in, size\+\_\+t in\+\_\+size, uint8\+\_\+t $\ast$out, size\+\_\+t $\ast$out\+\_\+pos, size\+\_\+t out\+\_\+size, bool try\+\_\+to\+\_\+compress)
\item 
\textbf{ lzma\+\_\+ret} \textbf{ lzma\+\_\+block\+\_\+buffer\+\_\+encode} (\textbf{ lzma\+\_\+block} $\ast$block, const \textbf{ lzma\+\_\+allocator} $\ast$allocator, const uint8\+\_\+t $\ast$in, size\+\_\+t in\+\_\+size, uint8\+\_\+t $\ast$out, size\+\_\+t $\ast$out\+\_\+pos, size\+\_\+t out\+\_\+size)
\begin{DoxyCompactList}\small\item\em Single-\/call .xz Block encoder. \end{DoxyCompactList}\item 
\textbf{ lzma\+\_\+ret} \textbf{ lzma\+\_\+block\+\_\+uncomp\+\_\+encode} (\textbf{ lzma\+\_\+block} $\ast$block, const uint8\+\_\+t $\ast$in, size\+\_\+t in\+\_\+size, uint8\+\_\+t $\ast$out, size\+\_\+t $\ast$out\+\_\+pos, size\+\_\+t out\+\_\+size)
\begin{DoxyCompactList}\small\item\em Single-\/call uncompressed .xz Block encoder. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
Single-\/call .xz Block encoder. 



\subsection{Macro Definition Documentation}
\mbox{\label{block__buffer__encoder_8c_a6cf3bc89aed406bb48c785dca58ae9da}} 
\index{block\+\_\+buffer\+\_\+encoder.\+c@{block\+\_\+buffer\+\_\+encoder.\+c}!H\+E\+A\+D\+E\+R\+S\+\_\+\+B\+O\+U\+ND@{H\+E\+A\+D\+E\+R\+S\+\_\+\+B\+O\+U\+ND}}
\index{H\+E\+A\+D\+E\+R\+S\+\_\+\+B\+O\+U\+ND@{H\+E\+A\+D\+E\+R\+S\+\_\+\+B\+O\+U\+ND}!block\+\_\+buffer\+\_\+encoder.\+c@{block\+\_\+buffer\+\_\+encoder.\+c}}
\subsubsection{H\+E\+A\+D\+E\+R\+S\+\_\+\+B\+O\+U\+ND}
{\footnotesize\ttfamily \#define H\+E\+A\+D\+E\+R\+S\+\_\+\+B\+O\+U\+ND}

{\bfseries Value\+:}
\begin{DoxyCode}
((1 + 1 + 2 * LZMA_VLI_BYTES_MAX + 3 + 4 \(\backslash\)
                + LZMA_CHECK_SIZE_MAX + 3) & ~3)
\end{DoxyCode}
Estimate the maximum size of the Block Header and Check fields for a Block that uses L\+Z\+M\+A2 uncompressed chunks. We could use \doxyref{lzma\+\_\+block\+\_\+header\+\_\+size()}{p.}{block_8h_ae9b47abc872d0b02c2da9d3fa5a7dacd} but this is simpler.

Block Header Size + Block Flags + Compressed Size
\begin{DoxyItemize}
\item Uncompressed Size + Filter Flags for L\+Z\+M\+A2 + C\+R\+C32 + Check and round up to the next multiple of four to take Header Padding into account. 
\end{DoxyItemize}

\subsection{Function Documentation}
\mbox{\label{block__buffer__encoder_8c_a1fbb846b46ee307a065f86777ce8994e}} 
\index{block\+\_\+buffer\+\_\+encoder.\+c@{block\+\_\+buffer\+\_\+encoder.\+c}!lzma\+\_\+block\+\_\+buffer\+\_\+bound64@{lzma\+\_\+block\+\_\+buffer\+\_\+bound64}}
\index{lzma\+\_\+block\+\_\+buffer\+\_\+bound64@{lzma\+\_\+block\+\_\+buffer\+\_\+bound64}!block\+\_\+buffer\+\_\+encoder.\+c@{block\+\_\+buffer\+\_\+encoder.\+c}}
\subsubsection{lzma\+\_\+block\+\_\+buffer\+\_\+bound64()}
{\footnotesize\ttfamily uint64\+\_\+t lzma\+\_\+block\+\_\+buffer\+\_\+bound64 (\begin{DoxyParamCaption}\item[{uint64\+\_\+t}]{uncompressed\+\_\+size }\end{DoxyParamCaption})}

uint64\+\_\+t version of \doxyref{lzma\+\_\+block\+\_\+buffer\+\_\+bound()}{p.}{block_8h_a58ff73e2572b529f48cc590bfffe5b4f}. It is used by \doxyref{stream\+\_\+encoder\+\_\+mt.\+c}{p.}{stream__encoder__mt_8c}. Probably the original \doxyref{lzma\+\_\+block\+\_\+buffer\+\_\+bound()}{p.}{block_8h_a58ff73e2572b529f48cc590bfffe5b4f} should have been 64-\/bit, but fixing it would break the A\+BI. \mbox{\label{block__buffer__encoder_8c_afcfe5ca83fac7bfbd1a0a7d41e32306d}} 
\index{block\+\_\+buffer\+\_\+encoder.\+c@{block\+\_\+buffer\+\_\+encoder.\+c}!lzma\+\_\+block\+\_\+buffer\+\_\+bound@{lzma\+\_\+block\+\_\+buffer\+\_\+bound}}
\index{lzma\+\_\+block\+\_\+buffer\+\_\+bound@{lzma\+\_\+block\+\_\+buffer\+\_\+bound}!block\+\_\+buffer\+\_\+encoder.\+c@{block\+\_\+buffer\+\_\+encoder.\+c}}
\subsubsection{lzma\+\_\+block\+\_\+buffer\+\_\+bound()}
{\footnotesize\ttfamily size\+\_\+t lzma\+\_\+block\+\_\+buffer\+\_\+bound (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{uncompressed\+\_\+size }\end{DoxyParamCaption})}



Calculate maximum output size for single-\/call Block encoding. 

This is equivalent to \doxyref{lzma\+\_\+stream\+\_\+buffer\+\_\+bound()}{p.}{container_8h_a66d4366a47b8332bff2a512f44f5c45e} but for .xz Blocks. See the documentation of \doxyref{lzma\+\_\+stream\+\_\+buffer\+\_\+bound()}{p.}{container_8h_a66d4366a47b8332bff2a512f44f5c45e}. \mbox{\label{block__buffer__encoder_8c_a037f3f6311573f0a8d16fb19fa634dcc}} 
\index{block\+\_\+buffer\+\_\+encoder.\+c@{block\+\_\+buffer\+\_\+encoder.\+c}!lzma\+\_\+block\+\_\+buffer\+\_\+encode@{lzma\+\_\+block\+\_\+buffer\+\_\+encode}}
\index{lzma\+\_\+block\+\_\+buffer\+\_\+encode@{lzma\+\_\+block\+\_\+buffer\+\_\+encode}!block\+\_\+buffer\+\_\+encoder.\+c@{block\+\_\+buffer\+\_\+encoder.\+c}}
\subsubsection{lzma\+\_\+block\+\_\+buffer\+\_\+encode()}
{\footnotesize\ttfamily \textbf{ lzma\+\_\+ret} lzma\+\_\+block\+\_\+buffer\+\_\+encode (\begin{DoxyParamCaption}\item[{\textbf{ lzma\+\_\+block} $\ast$}]{block,  }\item[{const \textbf{ lzma\+\_\+allocator} $\ast$}]{allocator,  }\item[{const uint8\+\_\+t $\ast$}]{in,  }\item[{size\+\_\+t}]{in\+\_\+size,  }\item[{uint8\+\_\+t $\ast$}]{out,  }\item[{size\+\_\+t $\ast$}]{out\+\_\+pos,  }\item[{size\+\_\+t}]{out\+\_\+size }\end{DoxyParamCaption})}



Single-\/call .xz Block encoder. 

In contrast to the multi-\/call encoder initialized with \doxyref{lzma\+\_\+block\+\_\+encoder()}{p.}{block_8h_a2218a49025a0b44f9a6f9d6d24359359}, this function encodes also the Block Header. This is required to make it possible to write appropriate Block Header also in case the data isn\textquotesingle{}t compressible, and different filter chain has to be used to encode the data in uncompressed form using uncompressed chunks of the L\+Z\+M\+A2 filter.

When the data isn\textquotesingle{}t compressible, header\+\_\+size, compressed\+\_\+size, and uncompressed\+\_\+size are set just like when the data was compressible, but it is possible that header\+\_\+size is too small to hold the filter chain specified in block-\/$>$filters, because that isn\textquotesingle{}t necessarily the filter chain that was actually used to encode the data. \doxyref{lzma\+\_\+block\+\_\+unpadded\+\_\+size()}{p.}{block_8h_a412d5605280fa29befae1b89e344bf30} still works normally, because it doesn\textquotesingle{}t read the filters array.


\begin{DoxyParams}{Parameters}
{\em block} & Block options\+: block-\/$>$version, block-\/$>$check, and block-\/$>$filters must have been initialized. \\
\hline
{\em allocator} & \doxyref{lzma\+\_\+allocator}{p.}{structlzma__allocator} for custom allocator functions. Set to N\+U\+LL to use malloc() and free(). \\
\hline
{\em in} & Beginning of the input buffer \\
\hline
{\em in\+\_\+size} & Size of the input buffer \\
\hline
{\em out} & Beginning of the output buffer \\
\hline
{\em out\+\_\+pos} & The next byte will be written to out[$\ast$out\+\_\+pos]. $\ast$out\+\_\+pos is updated only if encoding succeeds. \\
\hline
{\em out\+\_\+size} & Size of the out buffer; the first byte into which no data is written to is out[out\+\_\+size].\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
-\/ L\+Z\+M\+A\+\_\+\+OK\+: Encoding was successful.
\begin{DoxyItemize}
\item L\+Z\+M\+A\+\_\+\+B\+U\+F\+\_\+\+E\+R\+R\+OR\+: Not enough output buffer space.
\item L\+Z\+M\+A\+\_\+\+U\+N\+S\+U\+P\+P\+O\+R\+T\+E\+D\+\_\+\+C\+H\+E\+CK
\item L\+Z\+M\+A\+\_\+\+O\+P\+T\+I\+O\+N\+S\+\_\+\+E\+R\+R\+OR
\item L\+Z\+M\+A\+\_\+\+M\+E\+M\+\_\+\+E\+R\+R\+OR
\item L\+Z\+M\+A\+\_\+\+D\+A\+T\+A\+\_\+\+E\+R\+R\+OR
\item L\+Z\+M\+A\+\_\+\+P\+R\+O\+G\+\_\+\+E\+R\+R\+OR 
\end{DoxyItemize}
\end{DoxyReturn}
\mbox{\label{block__buffer__encoder_8c_aadd553cf24913d38342c9d5dda7d1d21}} 
\index{block\+\_\+buffer\+\_\+encoder.\+c@{block\+\_\+buffer\+\_\+encoder.\+c}!lzma\+\_\+block\+\_\+uncomp\+\_\+encode@{lzma\+\_\+block\+\_\+uncomp\+\_\+encode}}
\index{lzma\+\_\+block\+\_\+uncomp\+\_\+encode@{lzma\+\_\+block\+\_\+uncomp\+\_\+encode}!block\+\_\+buffer\+\_\+encoder.\+c@{block\+\_\+buffer\+\_\+encoder.\+c}}
\subsubsection{lzma\+\_\+block\+\_\+uncomp\+\_\+encode()}
{\footnotesize\ttfamily \textbf{ lzma\+\_\+ret} lzma\+\_\+block\+\_\+uncomp\+\_\+encode (\begin{DoxyParamCaption}\item[{\textbf{ lzma\+\_\+block} $\ast$}]{block,  }\item[{const uint8\+\_\+t $\ast$}]{in,  }\item[{size\+\_\+t}]{in\+\_\+size,  }\item[{uint8\+\_\+t $\ast$}]{out,  }\item[{size\+\_\+t $\ast$}]{out\+\_\+pos,  }\item[{size\+\_\+t}]{out\+\_\+size }\end{DoxyParamCaption})}



Single-\/call uncompressed .xz Block encoder. 

This is like \doxyref{lzma\+\_\+block\+\_\+buffer\+\_\+encode()}{p.}{block_8h_af415fa5130ab64e8760e9c39e856fa54} except this doesn\textquotesingle{}t try to compress the data and instead encodes the data using L\+Z\+M\+A2 uncompressed chunks. The required output buffer size can be determined with \doxyref{lzma\+\_\+block\+\_\+buffer\+\_\+bound()}{p.}{block_8h_a58ff73e2572b529f48cc590bfffe5b4f}.

Since the data won\textquotesingle{}t be compressed, this function ignores block-\/$>$filters. This function doesn\textquotesingle{}t take \doxyref{lzma\+\_\+allocator}{p.}{structlzma__allocator} because this function doesn\textquotesingle{}t allocate any memory from the heap. 