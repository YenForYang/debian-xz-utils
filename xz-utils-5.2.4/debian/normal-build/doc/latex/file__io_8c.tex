\section{xz/file\+\_\+io.c File Reference}
\label{file__io_8c}\index{xz/file\+\_\+io.\+c@{xz/file\+\_\+io.\+c}}


File opening, unlinking, and closing.  


{\ttfamily \#include \char`\"{}private.\+h\char`\"{}}\newline
{\ttfamily \#include $<$fcntl.\+h$>$}\newline
{\ttfamily \#include $<$poll.\+h$>$}\newline
{\ttfamily \#include \char`\"{}tuklib\+\_\+open\+\_\+stdxxx.\+h\char`\"{}}\newline
\subsection*{Macros}
\begin{DoxyCompactItemize}
\item 
\mbox{\label{file__io_8c_a36fa9b2e726512bc17a7a6d3e39002be}} 
\#define {\bfseries O\+\_\+\+B\+I\+N\+A\+RY}~0
\item 
\mbox{\label{file__io_8c_a2e375ab32c7ef4581b026be28e4cc116}} 
\#define {\bfseries O\+\_\+\+N\+O\+C\+T\+TY}~0
\item 
\mbox{\label{file__io_8c_a1d87c9b080894cc4320da238a6f16a20}} 
\#define {\bfseries I\+S\+\_\+\+E\+A\+G\+A\+I\+N\+\_\+\+O\+R\+\_\+\+E\+W\+O\+U\+L\+D\+B\+L\+O\+CK}(e)~((e) == E\+A\+G\+A\+IN)
\end{DoxyCompactItemize}
\subsection*{Enumerations}
\begin{DoxyCompactItemize}
\item 
\mbox{\label{file__io_8c_a91b73465073a342270952c32caa32f77}} 
enum {\bfseries io\+\_\+wait\+\_\+ret} \{ {\bfseries I\+O\+\_\+\+W\+A\+I\+T\+\_\+\+M\+O\+RE}, 
{\bfseries I\+O\+\_\+\+W\+A\+I\+T\+\_\+\+E\+R\+R\+OR}, 
{\bfseries I\+O\+\_\+\+W\+A\+I\+T\+\_\+\+T\+I\+M\+E\+O\+UT}
 \}
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\label{file__io_8c_aec1e9629ef5cc3abf4d2e39bd8006710}} 
static bool {\bfseries io\+\_\+write\+\_\+buf} (\textbf{ file\+\_\+pair} $\ast$pair, const uint8\+\_\+t $\ast$buf, size\+\_\+t size)
\item 
void \textbf{ io\+\_\+init} (void)
\begin{DoxyCompactList}\small\item\em Initialize the I/O module. \end{DoxyCompactList}\item 
void \textbf{ io\+\_\+write\+\_\+to\+\_\+user\+\_\+abort\+\_\+pipe} (void)
\begin{DoxyCompactList}\small\item\em Write a byte to user\+\_\+abort\+\_\+pipe[1]. \end{DoxyCompactList}\item 
void \textbf{ io\+\_\+no\+\_\+sparse} (void)
\begin{DoxyCompactList}\small\item\em Disable creation of sparse files when decompressing. \end{DoxyCompactList}\item 
static io\+\_\+wait\+\_\+ret \textbf{ io\+\_\+wait} (\textbf{ file\+\_\+pair} $\ast$pair, int timeout, bool is\+\_\+reading)
\begin{DoxyCompactList}\small\item\em Waits for input or output to become available or for a signal. \end{DoxyCompactList}\item 
static void \textbf{ io\+\_\+unlink} (const char $\ast$name, const struct stat $\ast$known\+\_\+st)
\begin{DoxyCompactList}\small\item\em Unlink a file. \end{DoxyCompactList}\item 
static void \textbf{ io\+\_\+copy\+\_\+attrs} (const \textbf{ file\+\_\+pair} $\ast$pair)
\begin{DoxyCompactList}\small\item\em Copies owner/group and permissions. \end{DoxyCompactList}\item 
static bool \textbf{ io\+\_\+open\+\_\+src\+\_\+real} (\textbf{ file\+\_\+pair} $\ast$pair)
\begin{DoxyCompactList}\small\item\em Opens the source file. Returns false on success, true on error. \end{DoxyCompactList}\item 
\textbf{ file\+\_\+pair} $\ast$ \textbf{ io\+\_\+open\+\_\+src} (const char $\ast$src\+\_\+name)
\begin{DoxyCompactList}\small\item\em Open the source file. \end{DoxyCompactList}\item 
static void \textbf{ io\+\_\+close\+\_\+src} (\textbf{ file\+\_\+pair} $\ast$pair, bool success)
\begin{DoxyCompactList}\small\item\em Closes source file of the \doxyref{file\+\_\+pair}{p.}{structfile__pair} structure. \end{DoxyCompactList}\item 
\mbox{\label{file__io_8c_a0571f8f4694fe021d5d5a6b9859cba23}} 
static bool {\bfseries io\+\_\+open\+\_\+dest\+\_\+real} (\textbf{ file\+\_\+pair} $\ast$pair)
\item 
bool \textbf{ io\+\_\+open\+\_\+dest} (\textbf{ file\+\_\+pair} $\ast$pair)
\begin{DoxyCompactList}\small\item\em Open the destination file. \end{DoxyCompactList}\item 
static bool \textbf{ io\+\_\+close\+\_\+dest} (\textbf{ file\+\_\+pair} $\ast$pair, bool success)
\begin{DoxyCompactList}\small\item\em Closes destination file of the \doxyref{file\+\_\+pair}{p.}{structfile__pair} structure. \end{DoxyCompactList}\item 
void \textbf{ io\+\_\+close} (\textbf{ file\+\_\+pair} $\ast$pair, bool success)
\begin{DoxyCompactList}\small\item\em Closes the file descriptors and frees possible allocated memory. \end{DoxyCompactList}\item 
void \textbf{ io\+\_\+fix\+\_\+src\+\_\+pos} (\textbf{ file\+\_\+pair} $\ast$pair, size\+\_\+t rewind\+\_\+size)
\begin{DoxyCompactList}\small\item\em Fix the position in src\+\_\+fd. \end{DoxyCompactList}\item 
size\+\_\+t \textbf{ io\+\_\+read} (\textbf{ file\+\_\+pair} $\ast$pair, \textbf{ io\+\_\+buf} $\ast$buf\+\_\+union, size\+\_\+t size)
\begin{DoxyCompactList}\small\item\em Reads from the source file to a buffer. \end{DoxyCompactList}\item 
bool \textbf{ io\+\_\+pread} (\textbf{ file\+\_\+pair} $\ast$pair, \textbf{ io\+\_\+buf} $\ast$buf, size\+\_\+t size, off\+\_\+t pos)
\begin{DoxyCompactList}\small\item\em Read from source file from given offset to a buffer. \end{DoxyCompactList}\item 
\mbox{\label{file__io_8c_a5d532508f4cfd5470b0b1eeb301ec27f}} 
static bool {\bfseries is\+\_\+sparse} (const \textbf{ io\+\_\+buf} $\ast$buf)
\item 
bool \textbf{ io\+\_\+write} (\textbf{ file\+\_\+pair} $\ast$pair, const \textbf{ io\+\_\+buf} $\ast$buf, size\+\_\+t size)
\begin{DoxyCompactList}\small\item\em Writes a buffer to the destination file. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Variables}
\begin{DoxyCompactItemize}
\item 
\mbox{\label{file__io_8c_a0b21eecca73d4dc0b8a24bb53f381ca8}} 
static bool {\bfseries warn\+\_\+fchown}
\item 
static bool \textbf{ try\+\_\+sparse} = true
\begin{DoxyCompactList}\small\item\em If true, try to create sparse files when decompressing. \end{DoxyCompactList}\item 
static int \textbf{ stdin\+\_\+flags}
\item 
\mbox{\label{file__io_8c_a782a99a66fda7e6615eb7e3d6204fbc7}} 
static bool {\bfseries restore\+\_\+stdin\+\_\+flags} = false
\item 
static int \textbf{ stdout\+\_\+flags}
\item 
\mbox{\label{file__io_8c_a255ebebc1bd241c051b0082f1cf416ba}} 
static bool {\bfseries restore\+\_\+stdout\+\_\+flags} = false
\item 
static int \textbf{ user\+\_\+abort\+\_\+pipe} [2]
\end{DoxyCompactItemize}


\subsection{Detailed Description}
File opening, unlinking, and closing. 



\subsection{Function Documentation}
\mbox{\label{file__io_8c_a43bba613ce0efd6af387cd04458ede8d}} 
\index{file\+\_\+io.\+c@{file\+\_\+io.\+c}!io\+\_\+init@{io\+\_\+init}}
\index{io\+\_\+init@{io\+\_\+init}!file\+\_\+io.\+c@{file\+\_\+io.\+c}}
\subsubsection{io\+\_\+init()}
{\footnotesize\ttfamily void io\+\_\+init (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Initialize the I/O module. 

\mbox{\label{file__io_8c_a3e78657470e4fe9cc6755931b07f9f93}} 
\index{file\+\_\+io.\+c@{file\+\_\+io.\+c}!io\+\_\+write\+\_\+to\+\_\+user\+\_\+abort\+\_\+pipe@{io\+\_\+write\+\_\+to\+\_\+user\+\_\+abort\+\_\+pipe}}
\index{io\+\_\+write\+\_\+to\+\_\+user\+\_\+abort\+\_\+pipe@{io\+\_\+write\+\_\+to\+\_\+user\+\_\+abort\+\_\+pipe}!file\+\_\+io.\+c@{file\+\_\+io.\+c}}
\subsubsection{io\+\_\+write\+\_\+to\+\_\+user\+\_\+abort\+\_\+pipe()}
{\footnotesize\ttfamily void io\+\_\+write\+\_\+to\+\_\+user\+\_\+abort\+\_\+pipe (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Write a byte to user\+\_\+abort\+\_\+pipe[1]. 

This is called from a signal handler. \mbox{\label{file__io_8c_a26350b70a7ef7ae45e57f04157ade2aa}} 
\index{file\+\_\+io.\+c@{file\+\_\+io.\+c}!io\+\_\+no\+\_\+sparse@{io\+\_\+no\+\_\+sparse}}
\index{io\+\_\+no\+\_\+sparse@{io\+\_\+no\+\_\+sparse}!file\+\_\+io.\+c@{file\+\_\+io.\+c}}
\subsubsection{io\+\_\+no\+\_\+sparse()}
{\footnotesize\ttfamily void io\+\_\+no\+\_\+sparse (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Disable creation of sparse files when decompressing. 



References message(), try\+\_\+sparse, and V\+\_\+\+D\+E\+B\+UG.

\mbox{\label{file__io_8c_a6bec7737c5b829039195bd8e12d447e0}} 
\index{file\+\_\+io.\+c@{file\+\_\+io.\+c}!io\+\_\+wait@{io\+\_\+wait}}
\index{io\+\_\+wait@{io\+\_\+wait}!file\+\_\+io.\+c@{file\+\_\+io.\+c}}
\subsubsection{io\+\_\+wait()}
{\footnotesize\ttfamily static io\+\_\+wait\+\_\+ret io\+\_\+wait (\begin{DoxyParamCaption}\item[{\textbf{ file\+\_\+pair} $\ast$}]{pair,  }\item[{int}]{timeout,  }\item[{bool}]{is\+\_\+reading }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Waits for input or output to become available or for a signal. 

This uses the self-\/pipe trick to avoid a race condition that can occur if a signal is caught after user\+\_\+abort has been checked but before e.\+g. read() has been called. In that situation read() could block unless non-\/blocking I/O is used. With non-\/blocking I/O something like select() or poll() is needed to avoid a busy-\/wait loop, and the same race condition pops up again. There are pselect() (P\+O\+S\+I\+X-\/1.\+2001) and ppoll() (not in P\+O\+S\+IX) but neither is portable enough in 2013. The self-\/pipe trick is old and very portable. 

References file\+\_\+pair\+::dest\+\_\+fd, file\+\_\+pair\+::src\+\_\+fd, user\+\_\+abort, and user\+\_\+abort\+\_\+pipe.

\mbox{\label{file__io_8c_a80290e05c048a6052bd8c35d7b69cfb6}} 
\index{file\+\_\+io.\+c@{file\+\_\+io.\+c}!io\+\_\+unlink@{io\+\_\+unlink}}
\index{io\+\_\+unlink@{io\+\_\+unlink}!file\+\_\+io.\+c@{file\+\_\+io.\+c}}
\subsubsection{io\+\_\+unlink()}
{\footnotesize\ttfamily static void io\+\_\+unlink (\begin{DoxyParamCaption}\item[{const char $\ast$}]{name,  }\item[{const struct stat $\ast$}]{known\+\_\+st }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Unlink a file. 

This tries to verify that the file being unlinked really is the file that we want to unlink by verifying device and inode numbers. There\textquotesingle{}s still a small unavoidable race, but this is much better than nothing (the file could have been moved/replaced even hours earlier). \mbox{\label{file__io_8c_a1884e01ba0a7757bb6fd96fa8a0bf09b}} 
\index{file\+\_\+io.\+c@{file\+\_\+io.\+c}!io\+\_\+copy\+\_\+attrs@{io\+\_\+copy\+\_\+attrs}}
\index{io\+\_\+copy\+\_\+attrs@{io\+\_\+copy\+\_\+attrs}!file\+\_\+io.\+c@{file\+\_\+io.\+c}}
\subsubsection{io\+\_\+copy\+\_\+attrs()}
{\footnotesize\ttfamily static void io\+\_\+copy\+\_\+attrs (\begin{DoxyParamCaption}\item[{const \textbf{ file\+\_\+pair} $\ast$}]{pair }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Copies owner/group and permissions. 

\begin{DoxyRefDesc}{Todo}
\item[\textbf{ Todo}]A\+CL and EA support \end{DoxyRefDesc}


References file\+\_\+pair\+::dest\+\_\+fd, and file\+\_\+pair\+::src\+\_\+st.

\mbox{\label{file__io_8c_af0470bc137d3ae386126db2ca94b5e65}} 
\index{file\+\_\+io.\+c@{file\+\_\+io.\+c}!io\+\_\+open\+\_\+src\+\_\+real@{io\+\_\+open\+\_\+src\+\_\+real}}
\index{io\+\_\+open\+\_\+src\+\_\+real@{io\+\_\+open\+\_\+src\+\_\+real}!file\+\_\+io.\+c@{file\+\_\+io.\+c}}
\subsubsection{io\+\_\+open\+\_\+src\+\_\+real()}
{\footnotesize\ttfamily static bool io\+\_\+open\+\_\+src\+\_\+real (\begin{DoxyParamCaption}\item[{\textbf{ file\+\_\+pair} $\ast$}]{pair }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Opens the source file. Returns false on success, true on error. 



References file\+\_\+pair\+::src\+\_\+name.



Referenced by io\+\_\+open\+\_\+src().

\mbox{\label{file__io_8c_ac4fb03f340ee03676cbde913682a3719}} 
\index{file\+\_\+io.\+c@{file\+\_\+io.\+c}!io\+\_\+open\+\_\+src@{io\+\_\+open\+\_\+src}}
\index{io\+\_\+open\+\_\+src@{io\+\_\+open\+\_\+src}!file\+\_\+io.\+c@{file\+\_\+io.\+c}}
\subsubsection{io\+\_\+open\+\_\+src()}
{\footnotesize\ttfamily \textbf{ file\+\_\+pair}$\ast$ io\+\_\+open\+\_\+src (\begin{DoxyParamCaption}\item[{const char $\ast$}]{src\+\_\+name }\end{DoxyParamCaption})}



Open the source file. 



References io\+\_\+open\+\_\+src\+\_\+real(), is\+\_\+empty\+\_\+filename(), signals\+\_\+block(), signals\+\_\+unblock(), file\+\_\+pair\+::src\+\_\+fd, and file\+\_\+pair\+::src\+\_\+name.



Referenced by coder\+\_\+run().

\mbox{\label{file__io_8c_ac4e485a5d6cbb717f7eddfc8eae35841}} 
\index{file\+\_\+io.\+c@{file\+\_\+io.\+c}!io\+\_\+close\+\_\+src@{io\+\_\+close\+\_\+src}}
\index{io\+\_\+close\+\_\+src@{io\+\_\+close\+\_\+src}!file\+\_\+io.\+c@{file\+\_\+io.\+c}}
\subsubsection{io\+\_\+close\+\_\+src()}
{\footnotesize\ttfamily static void io\+\_\+close\+\_\+src (\begin{DoxyParamCaption}\item[{\textbf{ file\+\_\+pair} $\ast$}]{pair,  }\item[{bool}]{success }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Closes source file of the \doxyref{file\+\_\+pair}{p.}{structfile__pair} structure. 


\begin{DoxyParams}{Parameters}
{\em pair} & File whose src\+\_\+fd should be closed \\
\hline
{\em success} & If true, the file will be removed from the disk if closing succeeds and --keep hasn\textquotesingle{}t been used. \\
\hline
\end{DoxyParams}
\mbox{\label{file__io_8c_a51c7b0ad8b7829773a69972565b7d08d}} 
\index{file\+\_\+io.\+c@{file\+\_\+io.\+c}!io\+\_\+open\+\_\+dest@{io\+\_\+open\+\_\+dest}}
\index{io\+\_\+open\+\_\+dest@{io\+\_\+open\+\_\+dest}!file\+\_\+io.\+c@{file\+\_\+io.\+c}}
\subsubsection{io\+\_\+open\+\_\+dest()}
{\footnotesize\ttfamily bool io\+\_\+open\+\_\+dest (\begin{DoxyParamCaption}\item[{\textbf{ file\+\_\+pair} $\ast$}]{pair }\end{DoxyParamCaption})}



Open the destination file. 



References signals\+\_\+block().

\mbox{\label{file__io_8c_a2e1e4bee9c2f87daa8ec40b3072816a5}} 
\index{file\+\_\+io.\+c@{file\+\_\+io.\+c}!io\+\_\+close\+\_\+dest@{io\+\_\+close\+\_\+dest}}
\index{io\+\_\+close\+\_\+dest@{io\+\_\+close\+\_\+dest}!file\+\_\+io.\+c@{file\+\_\+io.\+c}}
\subsubsection{io\+\_\+close\+\_\+dest()}
{\footnotesize\ttfamily static bool io\+\_\+close\+\_\+dest (\begin{DoxyParamCaption}\item[{\textbf{ file\+\_\+pair} $\ast$}]{pair,  }\item[{bool}]{success }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Closes destination file of the \doxyref{file\+\_\+pair}{p.}{structfile__pair} structure. 


\begin{DoxyParams}{Parameters}
{\em pair} & File whose dest\+\_\+fd should be closed \\
\hline
{\em success} & If false, the file will be removed from the disk.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Zero if closing succeeds. On error, -\/1 is returned and error message printed. 
\end{DoxyReturn}
\mbox{\label{file__io_8c_a8dcc56461111f392398385820ad9c1d9}} 
\index{file\+\_\+io.\+c@{file\+\_\+io.\+c}!io\+\_\+close@{io\+\_\+close}}
\index{io\+\_\+close@{io\+\_\+close}!file\+\_\+io.\+c@{file\+\_\+io.\+c}}
\subsubsection{io\+\_\+close()}
{\footnotesize\ttfamily void io\+\_\+close (\begin{DoxyParamCaption}\item[{\textbf{ file\+\_\+pair} $\ast$}]{pair,  }\item[{bool}]{success }\end{DoxyParamCaption})}



Closes the file descriptors and frees possible allocated memory. 

The success argument determines if source or destination file gets unlinked\+:
\begin{DoxyItemize}
\item false\+: The destination file is unlinked.
\item true\+: The source file is unlinked unless writing to stdout or --keep was used. 
\end{DoxyItemize}

References file\+\_\+pair\+::dest\+\_\+fd, file\+\_\+pair\+::dest\+\_\+pending\+\_\+sparse, file\+\_\+pair\+::dest\+\_\+try\+\_\+sparse, and message\+\_\+error().

\mbox{\label{file__io_8c_aa06dd4cd771d5a19bc191ff334f0623a}} 
\index{file\+\_\+io.\+c@{file\+\_\+io.\+c}!io\+\_\+fix\+\_\+src\+\_\+pos@{io\+\_\+fix\+\_\+src\+\_\+pos}}
\index{io\+\_\+fix\+\_\+src\+\_\+pos@{io\+\_\+fix\+\_\+src\+\_\+pos}!file\+\_\+io.\+c@{file\+\_\+io.\+c}}
\subsubsection{io\+\_\+fix\+\_\+src\+\_\+pos()}
{\footnotesize\ttfamily void io\+\_\+fix\+\_\+src\+\_\+pos (\begin{DoxyParamCaption}\item[{\textbf{ file\+\_\+pair} $\ast$}]{pair,  }\item[{size\+\_\+t}]{rewind\+\_\+size }\end{DoxyParamCaption})}



Fix the position in src\+\_\+fd. 

This is used when --single-\/thream has been specified and decompression is successful. If the input file descriptor supports seeking, this function fixes the input position to point to the next byte after the decompressed stream.


\begin{DoxyParams}{Parameters}
{\em pair} & File pair having the source file open for reading \\
\hline
{\em rewind\+\_\+size} & How many bytes of extra have been read i.\+e. how much to seek backwards. \\
\hline
\end{DoxyParams}
\mbox{\label{file__io_8c_ae7642411c20e8800874f7f95489c8d9d}} 
\index{file\+\_\+io.\+c@{file\+\_\+io.\+c}!io\+\_\+read@{io\+\_\+read}}
\index{io\+\_\+read@{io\+\_\+read}!file\+\_\+io.\+c@{file\+\_\+io.\+c}}
\subsubsection{io\+\_\+read()}
{\footnotesize\ttfamily size\+\_\+t io\+\_\+read (\begin{DoxyParamCaption}\item[{\textbf{ file\+\_\+pair} $\ast$}]{pair,  }\item[{\textbf{ io\+\_\+buf} $\ast$}]{buf,  }\item[{size\+\_\+t}]{size }\end{DoxyParamCaption})}



Reads from the source file to a buffer. 


\begin{DoxyParams}{Parameters}
{\em pair} & File pair having the source file open for reading \\
\hline
{\em buf} & Destination buffer to hold the read data \\
\hline
{\em size} & Size of the buffer; assumed be smaller than S\+S\+I\+Z\+E\+\_\+\+M\+AX\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
On success, number of bytes read is returned. On end of file zero is returned and pair-\/$>$src\+\_\+eof set to true. On error, S\+I\+Z\+E\+\_\+\+M\+AX is returned and error message printed. 
\end{DoxyReturn}


Referenced by coder\+\_\+passthru().

\mbox{\label{file__io_8c_af0781545c818796c48a4ee8dadd2c2a7}} 
\index{file\+\_\+io.\+c@{file\+\_\+io.\+c}!io\+\_\+pread@{io\+\_\+pread}}
\index{io\+\_\+pread@{io\+\_\+pread}!file\+\_\+io.\+c@{file\+\_\+io.\+c}}
\subsubsection{io\+\_\+pread()}
{\footnotesize\ttfamily bool io\+\_\+pread (\begin{DoxyParamCaption}\item[{\textbf{ file\+\_\+pair} $\ast$}]{pair,  }\item[{\textbf{ io\+\_\+buf} $\ast$}]{buf,  }\item[{size\+\_\+t}]{size,  }\item[{off\+\_\+t}]{pos }\end{DoxyParamCaption})}



Read from source file from given offset to a buffer. 

This is remotely similar to standard pread(). This uses lseek() though, so the read offset is changed on each call.


\begin{DoxyParams}{Parameters}
{\em pair} & Seekable source file \\
\hline
{\em buf} & Destination buffer \\
\hline
{\em size} & Amount of data to read \\
\hline
{\em pos} & Offset relative to the beginning of the file, from which the data should be read.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
On success, false is returned. On error, error message is printed and true is returned. 
\end{DoxyReturn}


References message\+\_\+error(), and file\+\_\+pair\+::src\+\_\+fd.



Referenced by parse\+\_\+check\+\_\+value().

\mbox{\label{file__io_8c_a42ccfb816386ca04e622762bad58ef6f}} 
\index{file\+\_\+io.\+c@{file\+\_\+io.\+c}!io\+\_\+write@{io\+\_\+write}}
\index{io\+\_\+write@{io\+\_\+write}!file\+\_\+io.\+c@{file\+\_\+io.\+c}}
\subsubsection{io\+\_\+write()}
{\footnotesize\ttfamily bool io\+\_\+write (\begin{DoxyParamCaption}\item[{\textbf{ file\+\_\+pair} $\ast$}]{pair,  }\item[{const \textbf{ io\+\_\+buf} $\ast$}]{buf,  }\item[{size\+\_\+t}]{size }\end{DoxyParamCaption})}



Writes a buffer to the destination file. 


\begin{DoxyParams}{Parameters}
{\em pair} & File pair having the destination file open for writing \\
\hline
{\em buf} & Buffer containing the data to be written \\
\hline
{\em size} & Size of the buffer; assumed be smaller than S\+S\+I\+Z\+E\+\_\+\+M\+AX\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
On success, zero is returned. On error, -\/1 is returned and error message printed. 
\end{DoxyReturn}


Referenced by coder\+\_\+passthru().



\subsection{Variable Documentation}
\mbox{\label{file__io_8c_a96b3b450da5d99ec1f6bd3e57d5f340a}} 
\index{file\+\_\+io.\+c@{file\+\_\+io.\+c}!try\+\_\+sparse@{try\+\_\+sparse}}
\index{try\+\_\+sparse@{try\+\_\+sparse}!file\+\_\+io.\+c@{file\+\_\+io.\+c}}
\subsubsection{try\+\_\+sparse}
{\footnotesize\ttfamily bool try\+\_\+sparse = true\hspace{0.3cm}{\ttfamily [static]}}



If true, try to create sparse files when decompressing. 



Referenced by io\+\_\+no\+\_\+sparse().

\mbox{\label{file__io_8c_ae5a3f681b5fa78079dec361e3687e17d}} 
\index{file\+\_\+io.\+c@{file\+\_\+io.\+c}!stdin\+\_\+flags@{stdin\+\_\+flags}}
\index{stdin\+\_\+flags@{stdin\+\_\+flags}!file\+\_\+io.\+c@{file\+\_\+io.\+c}}
\subsubsection{stdin\+\_\+flags}
{\footnotesize\ttfamily int stdin\+\_\+flags\hspace{0.3cm}{\ttfamily [static]}}

File status flags of standard input. This is used by \doxyref{io\+\_\+open\+\_\+src()}{p.}{file__io_8c_ac4fb03f340ee03676cbde913682a3719} and \doxyref{io\+\_\+close\+\_\+src()}{p.}{file__io_8c_ac4e485a5d6cbb717f7eddfc8eae35841}. \mbox{\label{file__io_8c_aead170473661c2bec0f0a48adf5322b1}} 
\index{file\+\_\+io.\+c@{file\+\_\+io.\+c}!stdout\+\_\+flags@{stdout\+\_\+flags}}
\index{stdout\+\_\+flags@{stdout\+\_\+flags}!file\+\_\+io.\+c@{file\+\_\+io.\+c}}
\subsubsection{stdout\+\_\+flags}
{\footnotesize\ttfamily int stdout\+\_\+flags\hspace{0.3cm}{\ttfamily [static]}}

Original file status flags of standard output. This is used by \doxyref{io\+\_\+open\+\_\+dest()}{p.}{file__io_8c_a51c7b0ad8b7829773a69972565b7d08d} and \doxyref{io\+\_\+close\+\_\+dest()}{p.}{file__io_8c_a2e1e4bee9c2f87daa8ec40b3072816a5} to save and restore the flags. \mbox{\label{file__io_8c_aeee374753502820756bc9abdb203f1a3}} 
\index{file\+\_\+io.\+c@{file\+\_\+io.\+c}!user\+\_\+abort\+\_\+pipe@{user\+\_\+abort\+\_\+pipe}}
\index{user\+\_\+abort\+\_\+pipe@{user\+\_\+abort\+\_\+pipe}!file\+\_\+io.\+c@{file\+\_\+io.\+c}}
\subsubsection{user\+\_\+abort\+\_\+pipe}
{\footnotesize\ttfamily int user\+\_\+abort\+\_\+pipe[2]\hspace{0.3cm}{\ttfamily [static]}}

Self-\/pipe used together with the user\+\_\+abort variable to avoid race conditions with signal handling. 

Referenced by io\+\_\+wait().

