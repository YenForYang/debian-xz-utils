\section{liblzma/simple/simple\+\_\+coder.c File Reference}
\label{simple__coder_8c}\index{liblzma/simple/simple\+\_\+coder.\+c@{liblzma/simple/simple\+\_\+coder.\+c}}


Wrapper for simple filters.  


{\ttfamily \#include \char`\"{}simple\+\_\+private.\+h\char`\"{}}\newline
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
static \textbf{ lzma\+\_\+ret} \textbf{ copy\+\_\+or\+\_\+code} (\textbf{ lzma\+\_\+simple\+\_\+coder} $\ast$coder, const \textbf{ lzma\+\_\+allocator} $\ast$allocator, const uint8\+\_\+t $\ast$restrict in, size\+\_\+t $\ast$restrict in\+\_\+pos, size\+\_\+t in\+\_\+size, uint8\+\_\+t $\ast$restrict out, size\+\_\+t $\ast$restrict out\+\_\+pos, size\+\_\+t out\+\_\+size, \textbf{ lzma\+\_\+action} action)
\begin{DoxyCompactList}\small\item\em Copied or encodes/decodes more data to out[]. \end{DoxyCompactList}\item 
\mbox{\label{simple__coder_8c_a5dcd9f9ca1137aafe4732eaed2587185}} 
static size\+\_\+t {\bfseries call\+\_\+filter} (\textbf{ lzma\+\_\+simple\+\_\+coder} $\ast$coder, uint8\+\_\+t $\ast$buffer, size\+\_\+t size)
\item 
\mbox{\label{simple__coder_8c_a0e3d6e1cc6020bfce449ebbf556d3a8a}} 
static \textbf{ lzma\+\_\+ret} {\bfseries simple\+\_\+code} (void $\ast$coder\+\_\+ptr, const \textbf{ lzma\+\_\+allocator} $\ast$allocator, const uint8\+\_\+t $\ast$restrict in, size\+\_\+t $\ast$restrict in\+\_\+pos, size\+\_\+t in\+\_\+size, uint8\+\_\+t $\ast$restrict out, size\+\_\+t $\ast$restrict out\+\_\+pos, size\+\_\+t out\+\_\+size, \textbf{ lzma\+\_\+action} action)
\item 
\mbox{\label{simple__coder_8c_acaa632e05595edc2e512d49aa9a0eb6e}} 
static void {\bfseries simple\+\_\+coder\+\_\+end} (void $\ast$coder\+\_\+ptr, const \textbf{ lzma\+\_\+allocator} $\ast$allocator)
\item 
\mbox{\label{simple__coder_8c_a08423347f98c0cb8e31aa89427e6ed27}} 
static \textbf{ lzma\+\_\+ret} {\bfseries simple\+\_\+coder\+\_\+update} (void $\ast$coder\+\_\+ptr, const \textbf{ lzma\+\_\+allocator} $\ast$allocator, const \textbf{ lzma\+\_\+filter} $\ast$filters\+\_\+null \textbf{ lzma\+\_\+attribute}((\+\_\+\+\_\+unused\+\_\+\+\_\+)), const \textbf{ lzma\+\_\+filter} $\ast$reversed\+\_\+filters)
\item 
\mbox{\label{simple__coder_8c_aff53ad35e18f4f61d0f53f52d9f0dcc7}} 
\textbf{ lzma\+\_\+ret} {\bfseries lzma\+\_\+simple\+\_\+coder\+\_\+init} (\textbf{ lzma\+\_\+next\+\_\+coder} $\ast$next, const \textbf{ lzma\+\_\+allocator} $\ast$allocator, const \textbf{ lzma\+\_\+filter\+\_\+info} $\ast$\textbf{ filters}, size\+\_\+t($\ast$filter)(void $\ast$simple, uint32\+\_\+t now\+\_\+pos, bool is\+\_\+encoder, uint8\+\_\+t $\ast$buffer, size\+\_\+t size), size\+\_\+t simple\+\_\+size, size\+\_\+t unfiltered\+\_\+max, uint32\+\_\+t alignment, bool is\+\_\+encoder)
\end{DoxyCompactItemize}


\subsection{Detailed Description}
Wrapper for simple filters. 

Simple filters don\textquotesingle{}t change the size of the data i.\+e. number of bytes in equals the number of bytes out. 

\subsection{Function Documentation}
\mbox{\label{simple__coder_8c_a9a9508cc7883974f7adfea0e517754c5}} 
\index{simple\+\_\+coder.\+c@{simple\+\_\+coder.\+c}!copy\+\_\+or\+\_\+code@{copy\+\_\+or\+\_\+code}}
\index{copy\+\_\+or\+\_\+code@{copy\+\_\+or\+\_\+code}!simple\+\_\+coder.\+c@{simple\+\_\+coder.\+c}}
\subsubsection{copy\+\_\+or\+\_\+code()}
{\footnotesize\ttfamily static \textbf{ lzma\+\_\+ret} copy\+\_\+or\+\_\+code (\begin{DoxyParamCaption}\item[{\textbf{ lzma\+\_\+simple\+\_\+coder} $\ast$}]{coder,  }\item[{const \textbf{ lzma\+\_\+allocator} $\ast$}]{allocator,  }\item[{const uint8\+\_\+t $\ast$restrict}]{in,  }\item[{size\+\_\+t $\ast$restrict}]{in\+\_\+pos,  }\item[{size\+\_\+t}]{in\+\_\+size,  }\item[{uint8\+\_\+t $\ast$restrict}]{out,  }\item[{size\+\_\+t $\ast$restrict}]{out\+\_\+pos,  }\item[{size\+\_\+t}]{out\+\_\+size,  }\item[{\textbf{ lzma\+\_\+action}}]{action }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Copied or encodes/decodes more data to out[]. 

