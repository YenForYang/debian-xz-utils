\section{liblzma/common/index\+\_\+decoder.c File Reference}
\label{index__decoder_8c}\index{liblzma/common/index\+\_\+decoder.\+c@{liblzma/common/index\+\_\+decoder.\+c}}


Decodes the Index field.  


{\ttfamily \#include \char`\"{}index.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}check.\+h\char`\"{}}\newline
\subsection*{Data Structures}
\begin{DoxyCompactItemize}
\item 
struct \textbf{ lzma\+\_\+index\+\_\+coder}
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\label{index__decoder_8c_a2fe31c23233a6c4aebbc8cee2349fb03}} 
static \textbf{ lzma\+\_\+ret} {\bfseries index\+\_\+decode} (void $\ast$coder\+\_\+ptr, const \textbf{ lzma\+\_\+allocator} $\ast$allocator, const uint8\+\_\+t $\ast$restrict in, size\+\_\+t $\ast$restrict in\+\_\+pos, size\+\_\+t in\+\_\+size, uint8\+\_\+t $\ast$restrict out \textbf{ lzma\+\_\+attribute}((\+\_\+\+\_\+unused\+\_\+\+\_\+)), size\+\_\+t $\ast$restrict out\+\_\+pos \textbf{ lzma\+\_\+attribute}((\+\_\+\+\_\+unused\+\_\+\+\_\+)), size\+\_\+t out\+\_\+size \textbf{ lzma\+\_\+attribute}((\+\_\+\+\_\+unused\+\_\+\+\_\+)), \textbf{ lzma\+\_\+action} action \textbf{ lzma\+\_\+attribute}((\+\_\+\+\_\+unused\+\_\+\+\_\+)))
\item 
\mbox{\label{index__decoder_8c_a706865878c00d9ed8e0753ee45a2af13}} 
static void {\bfseries index\+\_\+decoder\+\_\+end} (void $\ast$coder\+\_\+ptr, const \textbf{ lzma\+\_\+allocator} $\ast$allocator)
\item 
\mbox{\label{index__decoder_8c_a17d135aa9635eea8f84d38d0a0873614}} 
static \textbf{ lzma\+\_\+ret} {\bfseries index\+\_\+decoder\+\_\+memconfig} (void $\ast$coder\+\_\+ptr, uint64\+\_\+t $\ast$memusage, uint64\+\_\+t $\ast$old\+\_\+memlimit, uint64\+\_\+t new\+\_\+memlimit)
\item 
\mbox{\label{index__decoder_8c_a3be65def39bfda56621646287ee04d90}} 
static \textbf{ lzma\+\_\+ret} {\bfseries index\+\_\+decoder\+\_\+reset} (\textbf{ lzma\+\_\+index\+\_\+coder} $\ast$coder, const \textbf{ lzma\+\_\+allocator} $\ast$allocator, \textbf{ lzma\+\_\+index} $\ast$$\ast$i, uint64\+\_\+t memlimit)
\item 
\mbox{\label{index__decoder_8c_ada37eb9a2b477f277bc18d2f06f576b0}} 
static \textbf{ lzma\+\_\+ret} {\bfseries index\+\_\+decoder\+\_\+init} (\textbf{ lzma\+\_\+next\+\_\+coder} $\ast$next, const \textbf{ lzma\+\_\+allocator} $\ast$allocator, \textbf{ lzma\+\_\+index} $\ast$$\ast$i, uint64\+\_\+t memlimit)
\item 
\textbf{ lzma\+\_\+ret} \textbf{ lzma\+\_\+index\+\_\+decoder} (\textbf{ lzma\+\_\+stream} $\ast$\textbf{ strm}, \textbf{ lzma\+\_\+index} $\ast$$\ast$i, uint64\+\_\+t memlimit)
\begin{DoxyCompactList}\small\item\em Initialize .xz Index decoder. \end{DoxyCompactList}\item 
\textbf{ lzma\+\_\+ret} \textbf{ lzma\+\_\+index\+\_\+buffer\+\_\+decode} (\textbf{ lzma\+\_\+index} $\ast$$\ast$i, uint64\+\_\+t $\ast$memlimit, const \textbf{ lzma\+\_\+allocator} $\ast$allocator, const uint8\+\_\+t $\ast$in, size\+\_\+t $\ast$in\+\_\+pos, size\+\_\+t in\+\_\+size)
\begin{DoxyCompactList}\small\item\em Single-\/call .xz Index decoder. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
Decodes the Index field. 



\subsection{Function Documentation}
\mbox{\label{index__decoder_8c_a8a43bb2ce4b3d5165db980fcdaa0a5ce}} 
\index{index\+\_\+decoder.\+c@{index\+\_\+decoder.\+c}!lzma\+\_\+index\+\_\+decoder@{lzma\+\_\+index\+\_\+decoder}}
\index{lzma\+\_\+index\+\_\+decoder@{lzma\+\_\+index\+\_\+decoder}!index\+\_\+decoder.\+c@{index\+\_\+decoder.\+c}}
\subsubsection{lzma\+\_\+index\+\_\+decoder()}
{\footnotesize\ttfamily \textbf{ lzma\+\_\+ret} lzma\+\_\+index\+\_\+decoder (\begin{DoxyParamCaption}\item[{\textbf{ lzma\+\_\+stream} $\ast$}]{strm,  }\item[{\textbf{ lzma\+\_\+index} $\ast$$\ast$}]{i,  }\item[{uint64\+\_\+t}]{memlimit }\end{DoxyParamCaption})}



Initialize .xz Index decoder. 


\begin{DoxyParams}{Parameters}
{\em strm} & Pointer to properly prepared \doxyref{lzma\+\_\+stream}{p.}{structlzma__stream} \\
\hline
{\em i} & The decoded Index will be made available via this pointer. Initially this function will set $\ast$i to N\+U\+LL (the old value is ignored). If decoding succeeds (\doxyref{lzma\+\_\+code()}{p.}{base_8h_a28cc09bc422d5ba1e0187c9f2af5d957} returns L\+Z\+M\+A\+\_\+\+S\+T\+R\+E\+A\+M\+\_\+\+E\+ND), $\ast$i will be set to point to a new lzma\+\_\+index, which the application has to later free with \doxyref{lzma\+\_\+index\+\_\+end()}{p.}{api_2lzma_2index_8h_a0c2d0009f07fc315d5ac89e4bcd25abd}. \\
\hline
{\em memlimit} & How much memory the resulting lzma\+\_\+index is allowed to require. liblzma 5.\+2.\+3 and earlier don\textquotesingle{}t allow 0 here and return L\+Z\+M\+A\+\_\+\+P\+R\+O\+G\+\_\+\+E\+R\+R\+OR; later versions treat 0 as if 1 had been specified.\\
\hline
\end{DoxyParams}
Valid `action\textquotesingle{} arguments to \doxyref{lzma\+\_\+code()}{p.}{base_8h_a28cc09bc422d5ba1e0187c9f2af5d957} are L\+Z\+M\+A\+\_\+\+R\+UN and L\+Z\+M\+A\+\_\+\+F\+I\+N\+I\+SH. There is no need to use L\+Z\+M\+A\+\_\+\+F\+I\+N\+I\+SH, but it\textquotesingle{}s allowed because it may simplify certain types of applications.

\begin{DoxyReturn}{Returns}
-\/ L\+Z\+M\+A\+\_\+\+OK\+: Initialization succeeded, continue with \doxyref{lzma\+\_\+code()}{p.}{base_8h_a28cc09bc422d5ba1e0187c9f2af5d957}.
\begin{DoxyItemize}
\item L\+Z\+M\+A\+\_\+\+M\+E\+M\+\_\+\+E\+R\+R\+OR
\item L\+Z\+M\+A\+\_\+\+P\+R\+O\+G\+\_\+\+E\+R\+R\+OR
\end{DoxyItemize}
\end{DoxyReturn}
liblzma 5.\+2.\+3 and older list also L\+Z\+M\+A\+\_\+\+M\+E\+M\+L\+I\+M\+I\+T\+\_\+\+E\+R\+R\+OR here but that error code has never been possible from this initialization function. 

References lzma\+\_\+next\+\_\+strm\+\_\+init.

\mbox{\label{index__decoder_8c_ab182a5bf92f68c23cbadbefd1d9942fc}} 
\index{index\+\_\+decoder.\+c@{index\+\_\+decoder.\+c}!lzma\+\_\+index\+\_\+buffer\+\_\+decode@{lzma\+\_\+index\+\_\+buffer\+\_\+decode}}
\index{lzma\+\_\+index\+\_\+buffer\+\_\+decode@{lzma\+\_\+index\+\_\+buffer\+\_\+decode}!index\+\_\+decoder.\+c@{index\+\_\+decoder.\+c}}
\subsubsection{lzma\+\_\+index\+\_\+buffer\+\_\+decode()}
{\footnotesize\ttfamily \textbf{ lzma\+\_\+ret} lzma\+\_\+index\+\_\+buffer\+\_\+decode (\begin{DoxyParamCaption}\item[{\textbf{ lzma\+\_\+index} $\ast$$\ast$}]{i,  }\item[{uint64\+\_\+t $\ast$}]{memlimit,  }\item[{const \textbf{ lzma\+\_\+allocator} $\ast$}]{allocator,  }\item[{const uint8\+\_\+t $\ast$}]{in,  }\item[{size\+\_\+t $\ast$}]{in\+\_\+pos,  }\item[{size\+\_\+t}]{in\+\_\+size }\end{DoxyParamCaption})}



Single-\/call .xz Index decoder. 


\begin{DoxyParams}{Parameters}
{\em i} & If decoding succeeds, $\ast$i will point to a new lzma\+\_\+index, which the application has to later free with \doxyref{lzma\+\_\+index\+\_\+end()}{p.}{api_2lzma_2index_8h_a0c2d0009f07fc315d5ac89e4bcd25abd}. If an error occurs, $\ast$i will be N\+U\+LL. The old value of $\ast$i is always ignored and thus doesn\textquotesingle{}t need to be initialized by the caller. \\
\hline
{\em memlimit} & Pointer to how much memory the resulting lzma\+\_\+index is allowed to require. The value pointed by this pointer is modified if and only if L\+Z\+M\+A\+\_\+\+M\+E\+M\+L\+I\+M\+I\+T\+\_\+\+E\+R\+R\+OR is returned. \\
\hline
{\em allocator} & Pointer to \doxyref{lzma\+\_\+allocator}{p.}{structlzma__allocator}, or N\+U\+LL to use malloc() \\
\hline
{\em in} & Beginning of the input buffer \\
\hline
{\em in\+\_\+pos} & The next byte will be read from in[$\ast$in\+\_\+pos]. $\ast$in\+\_\+pos is updated only if decoding succeeds. \\
\hline
{\em in\+\_\+size} & Size of the input buffer; the first byte that won\textquotesingle{}t be read is in[in\+\_\+size].\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
-\/ L\+Z\+M\+A\+\_\+\+OK\+: Decoding was successful.
\begin{DoxyItemize}
\item L\+Z\+M\+A\+\_\+\+M\+E\+M\+\_\+\+E\+R\+R\+OR
\item L\+Z\+M\+A\+\_\+\+M\+E\+M\+L\+I\+M\+I\+T\+\_\+\+E\+R\+R\+OR\+: Memory usage limit was reached. The minimum required memlimit value was stored to $\ast$memlimit.
\item L\+Z\+M\+A\+\_\+\+D\+A\+T\+A\+\_\+\+E\+R\+R\+OR
\item L\+Z\+M\+A\+\_\+\+P\+R\+O\+G\+\_\+\+E\+R\+R\+OR 
\end{DoxyItemize}
\end{DoxyReturn}


References L\+Z\+M\+A\+\_\+\+P\+R\+O\+G\+\_\+\+E\+R\+R\+OR, and return\+\_\+if\+\_\+error.

