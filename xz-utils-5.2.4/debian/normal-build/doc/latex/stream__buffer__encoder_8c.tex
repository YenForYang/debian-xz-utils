\section{liblzma/common/stream\+\_\+buffer\+\_\+encoder.c File Reference}
\label{stream__buffer__encoder_8c}\index{liblzma/common/stream\+\_\+buffer\+\_\+encoder.\+c@{liblzma/common/stream\+\_\+buffer\+\_\+encoder.\+c}}


Single-\/call .xz Stream encoder.  


{\ttfamily \#include \char`\"{}index.\+h\char`\"{}}\newline
\subsection*{Macros}
\begin{DoxyCompactItemize}
\item 
\#define \textbf{ I\+N\+D\+E\+X\+\_\+\+B\+O\+U\+ND}~((1 + 1 + 2 $\ast$ \textbf{ L\+Z\+M\+A\+\_\+\+V\+L\+I\+\_\+\+B\+Y\+T\+E\+S\+\_\+\+M\+AX} + 4 + 3) \& $\sim$3)
\item 
\#define \textbf{ H\+E\+A\+D\+E\+R\+S\+\_\+\+B\+O\+U\+ND}~(2 $\ast$ \textbf{ L\+Z\+M\+A\+\_\+\+S\+T\+R\+E\+A\+M\+\_\+\+H\+E\+A\+D\+E\+R\+\_\+\+S\+I\+ZE} + \textbf{ I\+N\+D\+E\+X\+\_\+\+B\+O\+U\+ND})
\begin{DoxyCompactList}\small\item\em Stream Header, Stream Footer, and Index. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
size\+\_\+t \textbf{ lzma\+\_\+stream\+\_\+buffer\+\_\+bound} (size\+\_\+t uncompressed\+\_\+size)
\begin{DoxyCompactList}\small\item\em Calculate output buffer size for single-\/call Stream encoder. \end{DoxyCompactList}\item 
\textbf{ lzma\+\_\+ret} \textbf{ lzma\+\_\+stream\+\_\+buffer\+\_\+encode} (\textbf{ lzma\+\_\+filter} $\ast$\textbf{ filters}, \textbf{ lzma\+\_\+check} \textbf{ check}, const \textbf{ lzma\+\_\+allocator} $\ast$allocator, const uint8\+\_\+t $\ast$in, size\+\_\+t in\+\_\+size, uint8\+\_\+t $\ast$out, size\+\_\+t $\ast$out\+\_\+pos\+\_\+ptr, size\+\_\+t out\+\_\+size)
\begin{DoxyCompactList}\small\item\em Single-\/call .xz Stream encoder. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
Single-\/call .xz Stream encoder. 



\subsection{Macro Definition Documentation}
\mbox{\label{stream__buffer__encoder_8c_ace1b0af8bcbc7079142ac2587b02615f}} 
\index{stream\+\_\+buffer\+\_\+encoder.\+c@{stream\+\_\+buffer\+\_\+encoder.\+c}!I\+N\+D\+E\+X\+\_\+\+B\+O\+U\+ND@{I\+N\+D\+E\+X\+\_\+\+B\+O\+U\+ND}}
\index{I\+N\+D\+E\+X\+\_\+\+B\+O\+U\+ND@{I\+N\+D\+E\+X\+\_\+\+B\+O\+U\+ND}!stream\+\_\+buffer\+\_\+encoder.\+c@{stream\+\_\+buffer\+\_\+encoder.\+c}}
\subsubsection{I\+N\+D\+E\+X\+\_\+\+B\+O\+U\+ND}
{\footnotesize\ttfamily \#define I\+N\+D\+E\+X\+\_\+\+B\+O\+U\+ND~((1 + 1 + 2 $\ast$ \textbf{ L\+Z\+M\+A\+\_\+\+V\+L\+I\+\_\+\+B\+Y\+T\+E\+S\+\_\+\+M\+AX} + 4 + 3) \& $\sim$3)}

Maximum size of Index that has exactly one Record. Index Indicator + Number of Records + Record + C\+R\+C32 rounded up to the next multiple of four. \mbox{\label{stream__buffer__encoder_8c_a6cf3bc89aed406bb48c785dca58ae9da}} 
\index{stream\+\_\+buffer\+\_\+encoder.\+c@{stream\+\_\+buffer\+\_\+encoder.\+c}!H\+E\+A\+D\+E\+R\+S\+\_\+\+B\+O\+U\+ND@{H\+E\+A\+D\+E\+R\+S\+\_\+\+B\+O\+U\+ND}}
\index{H\+E\+A\+D\+E\+R\+S\+\_\+\+B\+O\+U\+ND@{H\+E\+A\+D\+E\+R\+S\+\_\+\+B\+O\+U\+ND}!stream\+\_\+buffer\+\_\+encoder.\+c@{stream\+\_\+buffer\+\_\+encoder.\+c}}
\subsubsection{H\+E\+A\+D\+E\+R\+S\+\_\+\+B\+O\+U\+ND}
{\footnotesize\ttfamily \#define H\+E\+A\+D\+E\+R\+S\+\_\+\+B\+O\+U\+ND~(2 $\ast$ \textbf{ L\+Z\+M\+A\+\_\+\+S\+T\+R\+E\+A\+M\+\_\+\+H\+E\+A\+D\+E\+R\+\_\+\+S\+I\+ZE} + \textbf{ I\+N\+D\+E\+X\+\_\+\+B\+O\+U\+ND})}



Stream Header, Stream Footer, and Index. 



\subsection{Function Documentation}
\mbox{\label{stream__buffer__encoder_8c_a870286986caa1c0ac6ce6c4074284420}} 
\index{stream\+\_\+buffer\+\_\+encoder.\+c@{stream\+\_\+buffer\+\_\+encoder.\+c}!lzma\+\_\+stream\+\_\+buffer\+\_\+bound@{lzma\+\_\+stream\+\_\+buffer\+\_\+bound}}
\index{lzma\+\_\+stream\+\_\+buffer\+\_\+bound@{lzma\+\_\+stream\+\_\+buffer\+\_\+bound}!stream\+\_\+buffer\+\_\+encoder.\+c@{stream\+\_\+buffer\+\_\+encoder.\+c}}
\subsubsection{lzma\+\_\+stream\+\_\+buffer\+\_\+bound()}
{\footnotesize\ttfamily size\+\_\+t lzma\+\_\+stream\+\_\+buffer\+\_\+bound (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{uncompressed\+\_\+size }\end{DoxyParamCaption})}



Calculate output buffer size for single-\/call Stream encoder. 

When trying to compress uncompressible data, the encoded size will be slightly bigger than the input data. This function calculates how much output buffer space is required to be sure that \doxyref{lzma\+\_\+stream\+\_\+buffer\+\_\+encode()}{p.}{container_8h_a6e645ccaeace3b13a6981e03c6e190ad} doesn\textquotesingle{}t return L\+Z\+M\+A\+\_\+\+B\+U\+F\+\_\+\+E\+R\+R\+OR.

The calculated value is not exact, but it is guaranteed to be big enough. The actual maximum output space required may be slightly smaller (up to about 100 bytes). This should not be a problem in practice.

If the calculated maximum size doesn\textquotesingle{}t fit into size\+\_\+t or would make the Stream grow past L\+Z\+M\+A\+\_\+\+V\+L\+I\+\_\+\+M\+AX (which should never happen in practice), zero is returned to indicate the error.

\begin{DoxyNote}{Note}
The limit calculated by this function applies only to single-\/call encoding. Multi-\/call encoding may (and probably will) have larger maximum expansion when encoding uncompressible data. Currently there is no function to calculate the maximum expansion of multi-\/call encoding. 
\end{DoxyNote}
\mbox{\label{stream__buffer__encoder_8c_a67f2d3ab78626a8a52c64e207a433d0c}} 
\index{stream\+\_\+buffer\+\_\+encoder.\+c@{stream\+\_\+buffer\+\_\+encoder.\+c}!lzma\+\_\+stream\+\_\+buffer\+\_\+encode@{lzma\+\_\+stream\+\_\+buffer\+\_\+encode}}
\index{lzma\+\_\+stream\+\_\+buffer\+\_\+encode@{lzma\+\_\+stream\+\_\+buffer\+\_\+encode}!stream\+\_\+buffer\+\_\+encoder.\+c@{stream\+\_\+buffer\+\_\+encoder.\+c}}
\subsubsection{lzma\+\_\+stream\+\_\+buffer\+\_\+encode()}
{\footnotesize\ttfamily \textbf{ lzma\+\_\+ret} lzma\+\_\+stream\+\_\+buffer\+\_\+encode (\begin{DoxyParamCaption}\item[{\textbf{ lzma\+\_\+filter} $\ast$}]{filters,  }\item[{\textbf{ lzma\+\_\+check}}]{check,  }\item[{const \textbf{ lzma\+\_\+allocator} $\ast$}]{allocator,  }\item[{const uint8\+\_\+t $\ast$}]{in,  }\item[{size\+\_\+t}]{in\+\_\+size,  }\item[{uint8\+\_\+t $\ast$}]{out,  }\item[{size\+\_\+t $\ast$}]{out\+\_\+pos,  }\item[{size\+\_\+t}]{out\+\_\+size }\end{DoxyParamCaption})}



Single-\/call .xz Stream encoder. 


\begin{DoxyParams}{Parameters}
{\em filters} & Array of filters. This must be terminated with filters[n].id = L\+Z\+M\+A\+\_\+\+V\+L\+I\+\_\+\+U\+N\+K\+N\+O\+WN. See \doxyref{filter.\+h}{p.}{filter_8h} for more information. \\
\hline
{\em check} & Type of the integrity check to calculate from uncompressed data. \\
\hline
{\em allocator} & \doxyref{lzma\+\_\+allocator}{p.}{structlzma__allocator} for custom allocator functions. Set to N\+U\+LL to use malloc() and free(). \\
\hline
{\em in} & Beginning of the input buffer \\
\hline
{\em in\+\_\+size} & Size of the input buffer \\
\hline
{\em out} & Beginning of the output buffer \\
\hline
{\em out\+\_\+pos} & The next byte will be written to out[$\ast$out\+\_\+pos]. $\ast$out\+\_\+pos is updated only if encoding succeeds. \\
\hline
{\em out\+\_\+size} & Size of the out buffer; the first byte into which no data is written to is out[out\+\_\+size].\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
-\/ L\+Z\+M\+A\+\_\+\+OK\+: Encoding was successful.
\begin{DoxyItemize}
\item L\+Z\+M\+A\+\_\+\+B\+U\+F\+\_\+\+E\+R\+R\+OR\+: Not enough output buffer space.
\item L\+Z\+M\+A\+\_\+\+U\+N\+S\+U\+P\+P\+O\+R\+T\+E\+D\+\_\+\+C\+H\+E\+CK
\item L\+Z\+M\+A\+\_\+\+O\+P\+T\+I\+O\+N\+S\+\_\+\+E\+R\+R\+OR
\item L\+Z\+M\+A\+\_\+\+M\+E\+M\+\_\+\+E\+R\+R\+OR
\item L\+Z\+M\+A\+\_\+\+D\+A\+T\+A\+\_\+\+E\+R\+R\+OR
\item L\+Z\+M\+A\+\_\+\+P\+R\+O\+G\+\_\+\+E\+R\+R\+OR 
\end{DoxyItemize}
\end{DoxyReturn}
