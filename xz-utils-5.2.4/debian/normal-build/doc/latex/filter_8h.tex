\section{liblzma/api/lzma/filter.h File Reference}
\label{filter_8h}\index{liblzma/api/lzma/filter.\+h@{liblzma/api/lzma/filter.\+h}}


Common filter related types and functions.  


\subsection*{Data Structures}
\begin{DoxyCompactItemize}
\item 
struct \textbf{ lzma\+\_\+filter}
\begin{DoxyCompactList}\small\item\em Filter options. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Macros}
\begin{DoxyCompactItemize}
\item 
\#define \textbf{ L\+Z\+M\+A\+\_\+\+F\+I\+L\+T\+E\+R\+S\+\_\+\+M\+AX}~4
\begin{DoxyCompactList}\small\item\em Maximum number of filters in a chain. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\textbf{ lzma\+\_\+bool} \textbf{ lzma\+\_\+filter\+\_\+encoder\+\_\+is\+\_\+supported} (\textbf{ lzma\+\_\+vli} \textbf{ id}) lzma\+\_\+nothrow lzma\+\_\+attr\+\_\+const
\begin{DoxyCompactList}\small\item\em Test if the given Filter ID is supported for encoding. \end{DoxyCompactList}\item 
\textbf{ lzma\+\_\+bool} \textbf{ lzma\+\_\+filter\+\_\+decoder\+\_\+is\+\_\+supported} (\textbf{ lzma\+\_\+vli} \textbf{ id}) lzma\+\_\+nothrow lzma\+\_\+attr\+\_\+const
\begin{DoxyCompactList}\small\item\em Test if the given Filter ID is supported for decoding. \end{DoxyCompactList}\item 
\textbf{ lzma\+\_\+ret} \textbf{ lzma\+\_\+filters\+\_\+copy} (const \textbf{ lzma\+\_\+filter} $\ast$src, \textbf{ lzma\+\_\+filter} $\ast$dest, const \textbf{ lzma\+\_\+allocator} $\ast$allocator) lzma\+\_\+nothrow
\begin{DoxyCompactList}\small\item\em Copy the filters array. \end{DoxyCompactList}\item 
uint64\+\_\+t \textbf{ lzma\+\_\+raw\+\_\+encoder\+\_\+memusage} (const \textbf{ lzma\+\_\+filter} $\ast$\textbf{ filters}) lzma\+\_\+nothrow lzma\+\_\+attr\+\_\+pure
\begin{DoxyCompactList}\small\item\em Calculate approximate memory requirements for raw encoder. \end{DoxyCompactList}\item 
uint64\+\_\+t \textbf{ lzma\+\_\+raw\+\_\+decoder\+\_\+memusage} (const \textbf{ lzma\+\_\+filter} $\ast$\textbf{ filters}) lzma\+\_\+nothrow lzma\+\_\+attr\+\_\+pure
\begin{DoxyCompactList}\small\item\em Calculate approximate memory requirements for raw decoder. \end{DoxyCompactList}\item 
\textbf{ lzma\+\_\+ret} \textbf{ lzma\+\_\+raw\+\_\+encoder} (\textbf{ lzma\+\_\+stream} $\ast$\textbf{ strm}, const \textbf{ lzma\+\_\+filter} $\ast$\textbf{ filters}) lzma\+\_\+nothrow lzma\+\_\+attr\+\_\+warn\+\_\+unused\+\_\+result
\begin{DoxyCompactList}\small\item\em Initialize raw encoder. \end{DoxyCompactList}\item 
\textbf{ lzma\+\_\+ret} \textbf{ lzma\+\_\+raw\+\_\+decoder} (\textbf{ lzma\+\_\+stream} $\ast$\textbf{ strm}, const \textbf{ lzma\+\_\+filter} $\ast$\textbf{ filters}) lzma\+\_\+nothrow lzma\+\_\+attr\+\_\+warn\+\_\+unused\+\_\+result
\begin{DoxyCompactList}\small\item\em Initialize raw decoder. \end{DoxyCompactList}\item 
\textbf{ lzma\+\_\+ret} \textbf{ lzma\+\_\+filters\+\_\+update} (\textbf{ lzma\+\_\+stream} $\ast$\textbf{ strm}, const \textbf{ lzma\+\_\+filter} $\ast$\textbf{ filters}) lzma\+\_\+nothrow
\begin{DoxyCompactList}\small\item\em Update the filter chain in the encoder. \end{DoxyCompactList}\item 
\textbf{ lzma\+\_\+ret} \textbf{ lzma\+\_\+raw\+\_\+buffer\+\_\+encode} (const \textbf{ lzma\+\_\+filter} $\ast$\textbf{ filters}, const \textbf{ lzma\+\_\+allocator} $\ast$allocator, const uint8\+\_\+t $\ast$in, size\+\_\+t in\+\_\+size, uint8\+\_\+t $\ast$out, size\+\_\+t $\ast$out\+\_\+pos, size\+\_\+t out\+\_\+size) lzma\+\_\+nothrow
\begin{DoxyCompactList}\small\item\em Single-\/call raw encoder. \end{DoxyCompactList}\item 
\textbf{ lzma\+\_\+ret} \textbf{ lzma\+\_\+raw\+\_\+buffer\+\_\+decode} (const \textbf{ lzma\+\_\+filter} $\ast$\textbf{ filters}, const \textbf{ lzma\+\_\+allocator} $\ast$allocator, const uint8\+\_\+t $\ast$in, size\+\_\+t $\ast$in\+\_\+pos, size\+\_\+t in\+\_\+size, uint8\+\_\+t $\ast$out, size\+\_\+t $\ast$out\+\_\+pos, size\+\_\+t out\+\_\+size) lzma\+\_\+nothrow
\begin{DoxyCompactList}\small\item\em Single-\/call raw decoder. \end{DoxyCompactList}\item 
\textbf{ lzma\+\_\+ret} \textbf{ lzma\+\_\+properties\+\_\+size} (uint32\+\_\+t $\ast$size, const \textbf{ lzma\+\_\+filter} $\ast$filter) lzma\+\_\+nothrow
\begin{DoxyCompactList}\small\item\em Get the size of the Filter Properties field. \end{DoxyCompactList}\item 
\textbf{ lzma\+\_\+ret} \textbf{ lzma\+\_\+properties\+\_\+encode} (const \textbf{ lzma\+\_\+filter} $\ast$filter, uint8\+\_\+t $\ast$props) lzma\+\_\+nothrow
\begin{DoxyCompactList}\small\item\em Encode the Filter Properties field. \end{DoxyCompactList}\item 
\textbf{ lzma\+\_\+ret} \textbf{ lzma\+\_\+properties\+\_\+decode} (\textbf{ lzma\+\_\+filter} $\ast$filter, const \textbf{ lzma\+\_\+allocator} $\ast$allocator, const uint8\+\_\+t $\ast$props, size\+\_\+t props\+\_\+size) lzma\+\_\+nothrow
\begin{DoxyCompactList}\small\item\em Decode the Filter Properties field. \end{DoxyCompactList}\item 
\textbf{ lzma\+\_\+ret} \textbf{ lzma\+\_\+filter\+\_\+flags\+\_\+size} (uint32\+\_\+t $\ast$size, const \textbf{ lzma\+\_\+filter} $\ast$filter) lzma\+\_\+nothrow lzma\+\_\+attr\+\_\+warn\+\_\+unused\+\_\+result
\begin{DoxyCompactList}\small\item\em Calculate encoded size of a Filter Flags field. \end{DoxyCompactList}\item 
\textbf{ lzma\+\_\+ret} \textbf{ lzma\+\_\+filter\+\_\+flags\+\_\+encode} (const \textbf{ lzma\+\_\+filter} $\ast$filter, uint8\+\_\+t $\ast$out, size\+\_\+t $\ast$out\+\_\+pos, size\+\_\+t out\+\_\+size) lzma\+\_\+nothrow lzma\+\_\+attr\+\_\+warn\+\_\+unused\+\_\+result
\begin{DoxyCompactList}\small\item\em Encode Filter Flags into given buffer. \end{DoxyCompactList}\item 
\textbf{ lzma\+\_\+ret} \textbf{ lzma\+\_\+filter\+\_\+flags\+\_\+decode} (\textbf{ lzma\+\_\+filter} $\ast$filter, const \textbf{ lzma\+\_\+allocator} $\ast$allocator, const uint8\+\_\+t $\ast$in, size\+\_\+t $\ast$in\+\_\+pos, size\+\_\+t in\+\_\+size) lzma\+\_\+nothrow lzma\+\_\+attr\+\_\+warn\+\_\+unused\+\_\+result
\begin{DoxyCompactList}\small\item\em Decode Filter Flags from given buffer. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
Common filter related types and functions. 



\subsection{Macro Definition Documentation}
\mbox{\label{filter_8h_ab33c0cc1728bf390e5b84f8bce1928ba}} 
\index{filter.\+h@{filter.\+h}!L\+Z\+M\+A\+\_\+\+F\+I\+L\+T\+E\+R\+S\+\_\+\+M\+AX@{L\+Z\+M\+A\+\_\+\+F\+I\+L\+T\+E\+R\+S\+\_\+\+M\+AX}}
\index{L\+Z\+M\+A\+\_\+\+F\+I\+L\+T\+E\+R\+S\+\_\+\+M\+AX@{L\+Z\+M\+A\+\_\+\+F\+I\+L\+T\+E\+R\+S\+\_\+\+M\+AX}!filter.\+h@{filter.\+h}}
\subsubsection{L\+Z\+M\+A\+\_\+\+F\+I\+L\+T\+E\+R\+S\+\_\+\+M\+AX}
{\footnotesize\ttfamily \#define L\+Z\+M\+A\+\_\+\+F\+I\+L\+T\+E\+R\+S\+\_\+\+M\+AX~4}



Maximum number of filters in a chain. 

A filter chain can have 1-\/4 filters, of which three are allowed to change the size of the data. Usually only one or two filters are needed. 

Referenced by coder\+\_\+add\+\_\+filter(), lzma\+\_\+block\+\_\+header\+\_\+decode(), lzma\+\_\+block\+\_\+header\+\_\+encode(), and lzma\+\_\+block\+\_\+header\+\_\+size().



\subsection{Function Documentation}
\mbox{\label{filter_8h_a3db3c36cd6e57658a74c53e4daa2bef6}} 
\index{filter.\+h@{filter.\+h}!lzma\+\_\+filter\+\_\+encoder\+\_\+is\+\_\+supported@{lzma\+\_\+filter\+\_\+encoder\+\_\+is\+\_\+supported}}
\index{lzma\+\_\+filter\+\_\+encoder\+\_\+is\+\_\+supported@{lzma\+\_\+filter\+\_\+encoder\+\_\+is\+\_\+supported}!filter.\+h@{filter.\+h}}
\subsubsection{lzma\+\_\+filter\+\_\+encoder\+\_\+is\+\_\+supported()}
{\footnotesize\ttfamily \textbf{ lzma\+\_\+bool} lzma\+\_\+filter\+\_\+encoder\+\_\+is\+\_\+supported (\begin{DoxyParamCaption}\item[{\textbf{ lzma\+\_\+vli}}]{id }\end{DoxyParamCaption}) const}



Test if the given Filter ID is supported for encoding. 

Return true if the give Filter ID is supported for encoding by this liblzma build. Otherwise false is returned.

There is no way to list which filters are available in this particular liblzma version and build. It would be useless, because the application couldn\textquotesingle{}t know what kind of options the filter would need. \mbox{\label{filter_8h_acab0c67bf5b3a76f2b474c8e1da98938}} 
\index{filter.\+h@{filter.\+h}!lzma\+\_\+filter\+\_\+decoder\+\_\+is\+\_\+supported@{lzma\+\_\+filter\+\_\+decoder\+\_\+is\+\_\+supported}}
\index{lzma\+\_\+filter\+\_\+decoder\+\_\+is\+\_\+supported@{lzma\+\_\+filter\+\_\+decoder\+\_\+is\+\_\+supported}!filter.\+h@{filter.\+h}}
\subsubsection{lzma\+\_\+filter\+\_\+decoder\+\_\+is\+\_\+supported()}
{\footnotesize\ttfamily \textbf{ lzma\+\_\+bool} lzma\+\_\+filter\+\_\+decoder\+\_\+is\+\_\+supported (\begin{DoxyParamCaption}\item[{\textbf{ lzma\+\_\+vli}}]{id }\end{DoxyParamCaption}) const}



Test if the given Filter ID is supported for decoding. 

Return true if the give Filter ID is supported for decoding by this liblzma build. Otherwise false is returned. \mbox{\label{filter_8h_a9444898c3954345571a93c99cd139cf4}} 
\index{filter.\+h@{filter.\+h}!lzma\+\_\+filters\+\_\+copy@{lzma\+\_\+filters\+\_\+copy}}
\index{lzma\+\_\+filters\+\_\+copy@{lzma\+\_\+filters\+\_\+copy}!filter.\+h@{filter.\+h}}
\subsubsection{lzma\+\_\+filters\+\_\+copy()}
{\footnotesize\ttfamily \textbf{ lzma\+\_\+ret} lzma\+\_\+filters\+\_\+copy (\begin{DoxyParamCaption}\item[{const \textbf{ lzma\+\_\+filter} $\ast$}]{src,  }\item[{\textbf{ lzma\+\_\+filter} $\ast$}]{dest,  }\item[{const \textbf{ lzma\+\_\+allocator} $\ast$}]{allocator }\end{DoxyParamCaption})}



Copy the filters array. 

Copy the Filter I\+Ds and filter-\/specific options from src to dest. Up to L\+Z\+M\+A\+\_\+\+F\+I\+L\+T\+E\+R\+S\+\_\+\+M\+AX filters are copied, plus the terminating .id == L\+Z\+M\+A\+\_\+\+V\+L\+I\+\_\+\+U\+N\+K\+N\+O\+WN. Thus, dest should have at least L\+Z\+M\+A\+\_\+\+F\+I\+L\+T\+E\+R\+S\+\_\+\+M\+AX + 1 elements space unless the caller knows that src is smaller than that.

Unless the filter-\/specific options is N\+U\+LL, the Filter ID has to be supported by liblzma, because liblzma needs to know the size of every filter-\/specific options structure. The filter-\/specific options are not validated. If options is N\+U\+LL, any unsupported Filter I\+Ds are copied without returning an error.

Old filter-\/specific options in dest are not freed, so dest doesn\textquotesingle{}t need to be initialized by the caller in any way.

If an error occurs, memory possibly already allocated by this function is always freed.

\begin{DoxyReturn}{Returns}
-\/ L\+Z\+M\+A\+\_\+\+OK
\begin{DoxyItemize}
\item L\+Z\+M\+A\+\_\+\+M\+E\+M\+\_\+\+E\+R\+R\+OR
\item L\+Z\+M\+A\+\_\+\+O\+P\+T\+I\+O\+N\+S\+\_\+\+E\+R\+R\+OR\+: Unsupported Filter ID and its options is not N\+U\+LL.
\item L\+Z\+M\+A\+\_\+\+P\+R\+O\+G\+\_\+\+E\+R\+R\+OR\+: src or dest is N\+U\+LL. 
\end{DoxyItemize}
\end{DoxyReturn}
\mbox{\label{filter_8h_a730f9391e85a5979bcd1b32643ae7176}} 
\index{filter.\+h@{filter.\+h}!lzma\+\_\+raw\+\_\+encoder\+\_\+memusage@{lzma\+\_\+raw\+\_\+encoder\+\_\+memusage}}
\index{lzma\+\_\+raw\+\_\+encoder\+\_\+memusage@{lzma\+\_\+raw\+\_\+encoder\+\_\+memusage}!filter.\+h@{filter.\+h}}
\subsubsection{lzma\+\_\+raw\+\_\+encoder\+\_\+memusage()}
{\footnotesize\ttfamily uint64\+\_\+t lzma\+\_\+raw\+\_\+encoder\+\_\+memusage (\begin{DoxyParamCaption}\item[{const \textbf{ lzma\+\_\+filter} $\ast$}]{filters }\end{DoxyParamCaption})}



Calculate approximate memory requirements for raw encoder. 

This function can be used to calculate the memory requirements for Block and Stream encoders too because Block and Stream encoders don\textquotesingle{}t need significantly more memory than raw encoder.


\begin{DoxyParams}{Parameters}
{\em filters} & Array of filters terminated with .id == L\+Z\+M\+A\+\_\+\+V\+L\+I\+\_\+\+U\+N\+K\+N\+O\+WN.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Number of bytes of memory required for the given filter chain when encoding. If an error occurs, for example due to unsupported filter chain, U\+I\+N\+T64\+\_\+\+M\+AX is returned. 
\end{DoxyReturn}


Referenced by lzma\+\_\+filters\+\_\+update().

\mbox{\label{filter_8h_a58511249ae9206d7de7c5d1f05842297}} 
\index{filter.\+h@{filter.\+h}!lzma\+\_\+raw\+\_\+decoder\+\_\+memusage@{lzma\+\_\+raw\+\_\+decoder\+\_\+memusage}}
\index{lzma\+\_\+raw\+\_\+decoder\+\_\+memusage@{lzma\+\_\+raw\+\_\+decoder\+\_\+memusage}!filter.\+h@{filter.\+h}}
\subsubsection{lzma\+\_\+raw\+\_\+decoder\+\_\+memusage()}
{\footnotesize\ttfamily uint64\+\_\+t lzma\+\_\+raw\+\_\+decoder\+\_\+memusage (\begin{DoxyParamCaption}\item[{const \textbf{ lzma\+\_\+filter} $\ast$}]{filters }\end{DoxyParamCaption})}



Calculate approximate memory requirements for raw decoder. 

This function can be used to calculate the memory requirements for Block and Stream decoders too because Block and Stream decoders don\textquotesingle{}t need significantly more memory than raw decoder.


\begin{DoxyParams}{Parameters}
{\em filters} & Array of filters terminated with .id == L\+Z\+M\+A\+\_\+\+V\+L\+I\+\_\+\+U\+N\+K\+N\+O\+WN.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Number of bytes of memory required for the given filter chain when decoding. If an error occurs, for example due to unsupported filter chain, U\+I\+N\+T64\+\_\+\+M\+AX is returned. 
\end{DoxyReturn}
\mbox{\label{filter_8h_a2368e4129032345eb0738b0c6e085703}} 
\index{filter.\+h@{filter.\+h}!lzma\+\_\+raw\+\_\+encoder@{lzma\+\_\+raw\+\_\+encoder}}
\index{lzma\+\_\+raw\+\_\+encoder@{lzma\+\_\+raw\+\_\+encoder}!filter.\+h@{filter.\+h}}
\subsubsection{lzma\+\_\+raw\+\_\+encoder()}
{\footnotesize\ttfamily \textbf{ lzma\+\_\+ret} lzma\+\_\+raw\+\_\+encoder (\begin{DoxyParamCaption}\item[{\textbf{ lzma\+\_\+stream} $\ast$}]{strm,  }\item[{const \textbf{ lzma\+\_\+filter} $\ast$}]{filters }\end{DoxyParamCaption})}



Initialize raw encoder. 

This function may be useful when implementing custom file formats.


\begin{DoxyParams}{Parameters}
{\em strm} & Pointer to properly prepared \doxyref{lzma\+\_\+stream}{p.}{structlzma__stream} \\
\hline
{\em filters} & Array of \doxyref{lzma\+\_\+filter}{p.}{structlzma__filter} structures. The end of the array must be marked with .id = L\+Z\+M\+A\+\_\+\+V\+L\+I\+\_\+\+U\+N\+K\+N\+O\+WN.\\
\hline
\end{DoxyParams}
The `action\textquotesingle{} with \doxyref{lzma\+\_\+code()}{p.}{base_8h_a28cc09bc422d5ba1e0187c9f2af5d957} can be L\+Z\+M\+A\+\_\+\+R\+UN, L\+Z\+M\+A\+\_\+\+S\+Y\+N\+C\+\_\+\+F\+L\+U\+SH (if the filter chain supports it), or L\+Z\+M\+A\+\_\+\+F\+I\+N\+I\+SH.

\begin{DoxyReturn}{Returns}
-\/ L\+Z\+M\+A\+\_\+\+OK
\begin{DoxyItemize}
\item L\+Z\+M\+A\+\_\+\+M\+E\+M\+\_\+\+E\+R\+R\+OR
\item L\+Z\+M\+A\+\_\+\+O\+P\+T\+I\+O\+N\+S\+\_\+\+E\+R\+R\+OR
\item L\+Z\+M\+A\+\_\+\+P\+R\+O\+G\+\_\+\+E\+R\+R\+OR 
\end{DoxyItemize}
\end{DoxyReturn}


References lzma\+\_\+next\+\_\+strm\+\_\+init.

\mbox{\label{filter_8h_ae77b3b6c5eccd9d77bbafef0a8a203c1}} 
\index{filter.\+h@{filter.\+h}!lzma\+\_\+raw\+\_\+decoder@{lzma\+\_\+raw\+\_\+decoder}}
\index{lzma\+\_\+raw\+\_\+decoder@{lzma\+\_\+raw\+\_\+decoder}!filter.\+h@{filter.\+h}}
\subsubsection{lzma\+\_\+raw\+\_\+decoder()}
{\footnotesize\ttfamily \textbf{ lzma\+\_\+ret} lzma\+\_\+raw\+\_\+decoder (\begin{DoxyParamCaption}\item[{\textbf{ lzma\+\_\+stream} $\ast$}]{strm,  }\item[{const \textbf{ lzma\+\_\+filter} $\ast$}]{filters }\end{DoxyParamCaption})}



Initialize raw decoder. 

The initialization of raw decoder goes similarly to raw encoder.

The `action\textquotesingle{} with \doxyref{lzma\+\_\+code()}{p.}{base_8h_a28cc09bc422d5ba1e0187c9f2af5d957} can be L\+Z\+M\+A\+\_\+\+R\+UN or L\+Z\+M\+A\+\_\+\+F\+I\+N\+I\+SH. Using L\+Z\+M\+A\+\_\+\+F\+I\+N\+I\+SH is not required, it is supported just for convenience.

\begin{DoxyReturn}{Returns}
-\/ L\+Z\+M\+A\+\_\+\+OK
\begin{DoxyItemize}
\item L\+Z\+M\+A\+\_\+\+M\+E\+M\+\_\+\+E\+R\+R\+OR
\item L\+Z\+M\+A\+\_\+\+O\+P\+T\+I\+O\+N\+S\+\_\+\+E\+R\+R\+OR
\item L\+Z\+M\+A\+\_\+\+P\+R\+O\+G\+\_\+\+E\+R\+R\+OR 
\end{DoxyItemize}
\end{DoxyReturn}


References lzma\+\_\+next\+\_\+strm\+\_\+init.

\mbox{\label{filter_8h_a4a8fd969df001e449ebe4421ab33bba5}} 
\index{filter.\+h@{filter.\+h}!lzma\+\_\+filters\+\_\+update@{lzma\+\_\+filters\+\_\+update}}
\index{lzma\+\_\+filters\+\_\+update@{lzma\+\_\+filters\+\_\+update}!filter.\+h@{filter.\+h}}
\subsubsection{lzma\+\_\+filters\+\_\+update()}
{\footnotesize\ttfamily \textbf{ lzma\+\_\+ret} lzma\+\_\+filters\+\_\+update (\begin{DoxyParamCaption}\item[{\textbf{ lzma\+\_\+stream} $\ast$}]{strm,  }\item[{const \textbf{ lzma\+\_\+filter} $\ast$}]{filters }\end{DoxyParamCaption})}



Update the filter chain in the encoder. 

This function is for advanced users only. This function has two slightly different purposes\+:


\begin{DoxyItemize}
\item After L\+Z\+M\+A\+\_\+\+F\+U\+L\+L\+\_\+\+F\+L\+U\+SH when using Stream encoder\+: Set a new filter chain, which will be used starting from the next Block.
\item After L\+Z\+M\+A\+\_\+\+S\+Y\+N\+C\+\_\+\+F\+L\+U\+SH using Raw, Block, or Stream encoder\+: Change the filter-\/specific options in the middle of encoding. The actual filters in the chain (Filter I\+Ds) cannot be changed. In the future, it might become possible to change the filter options without using L\+Z\+M\+A\+\_\+\+S\+Y\+N\+C\+\_\+\+F\+L\+U\+SH.
\end{DoxyItemize}

While rarely useful, this function may be called also when no data has been compressed yet. In that case, this function will behave as if L\+Z\+M\+A\+\_\+\+F\+U\+L\+L\+\_\+\+F\+L\+U\+SH (Stream encoder) or L\+Z\+M\+A\+\_\+\+S\+Y\+N\+C\+\_\+\+F\+L\+U\+SH (Raw or Block encoder) had been used right before calling this function.

\begin{DoxyReturn}{Returns}
-\/ L\+Z\+M\+A\+\_\+\+OK
\begin{DoxyItemize}
\item L\+Z\+M\+A\+\_\+\+M\+E\+M\+\_\+\+E\+R\+R\+OR
\item L\+Z\+M\+A\+\_\+\+M\+E\+M\+L\+I\+M\+I\+T\+\_\+\+E\+R\+R\+OR
\item L\+Z\+M\+A\+\_\+\+O\+P\+T\+I\+O\+N\+S\+\_\+\+E\+R\+R\+OR
\item L\+Z\+M\+A\+\_\+\+P\+R\+O\+G\+\_\+\+E\+R\+R\+OR 
\end{DoxyItemize}
\end{DoxyReturn}


References filters, lzma\+\_\+stream\+::internal, L\+Z\+M\+A\+\_\+\+P\+R\+O\+G\+\_\+\+E\+R\+R\+OR, lzma\+\_\+raw\+\_\+encoder\+\_\+memusage(), lzma\+\_\+internal\+\_\+s\+::next, strm, and lzma\+\_\+next\+\_\+coder\+\_\+s\+::update.

\mbox{\label{filter_8h_a226724ab3391b410281fdf656cc7c432}} 
\index{filter.\+h@{filter.\+h}!lzma\+\_\+raw\+\_\+buffer\+\_\+encode@{lzma\+\_\+raw\+\_\+buffer\+\_\+encode}}
\index{lzma\+\_\+raw\+\_\+buffer\+\_\+encode@{lzma\+\_\+raw\+\_\+buffer\+\_\+encode}!filter.\+h@{filter.\+h}}
\subsubsection{lzma\+\_\+raw\+\_\+buffer\+\_\+encode()}
{\footnotesize\ttfamily \textbf{ lzma\+\_\+ret} lzma\+\_\+raw\+\_\+buffer\+\_\+encode (\begin{DoxyParamCaption}\item[{const \textbf{ lzma\+\_\+filter} $\ast$}]{filters,  }\item[{const \textbf{ lzma\+\_\+allocator} $\ast$}]{allocator,  }\item[{const uint8\+\_\+t $\ast$}]{in,  }\item[{size\+\_\+t}]{in\+\_\+size,  }\item[{uint8\+\_\+t $\ast$}]{out,  }\item[{size\+\_\+t $\ast$}]{out\+\_\+pos,  }\item[{size\+\_\+t}]{out\+\_\+size }\end{DoxyParamCaption})}



Single-\/call raw encoder. 


\begin{DoxyParams}{Parameters}
{\em filters} & Array of \doxyref{lzma\+\_\+filter}{p.}{structlzma__filter} structures. The end of the array must be marked with .id = L\+Z\+M\+A\+\_\+\+V\+L\+I\+\_\+\+U\+N\+K\+N\+O\+WN. \\
\hline
{\em allocator} & \doxyref{lzma\+\_\+allocator}{p.}{structlzma__allocator} for custom allocator functions. Set to N\+U\+LL to use malloc() and free(). \\
\hline
{\em in} & Beginning of the input buffer \\
\hline
{\em in\+\_\+size} & Size of the input buffer \\
\hline
{\em out} & Beginning of the output buffer \\
\hline
{\em out\+\_\+pos} & The next byte will be written to out[$\ast$out\+\_\+pos]. $\ast$out\+\_\+pos is updated only if encoding succeeds. \\
\hline
{\em out\+\_\+size} & Size of the out buffer; the first byte into which no data is written to is out[out\+\_\+size].\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
-\/ L\+Z\+M\+A\+\_\+\+OK\+: Encoding was successful.
\begin{DoxyItemize}
\item L\+Z\+M\+A\+\_\+\+B\+U\+F\+\_\+\+E\+R\+R\+OR\+: Not enough output buffer space.
\item L\+Z\+M\+A\+\_\+\+O\+P\+T\+I\+O\+N\+S\+\_\+\+E\+R\+R\+OR
\item L\+Z\+M\+A\+\_\+\+M\+E\+M\+\_\+\+E\+R\+R\+OR
\item L\+Z\+M\+A\+\_\+\+D\+A\+T\+A\+\_\+\+E\+R\+R\+OR
\item L\+Z\+M\+A\+\_\+\+P\+R\+O\+G\+\_\+\+E\+R\+R\+OR
\end{DoxyItemize}
\end{DoxyReturn}
\begin{DoxyNote}{Note}
There is no function to calculate how big output buffer would surely be big enough. (\doxyref{lzma\+\_\+stream\+\_\+buffer\+\_\+bound()}{p.}{container_8h_a66d4366a47b8332bff2a512f44f5c45e} works only for \doxyref{lzma\+\_\+stream\+\_\+buffer\+\_\+encode()}{p.}{container_8h_a6e645ccaeace3b13a6981e03c6e190ad}; raw encoder won\textquotesingle{}t necessarily meet that bound.) 
\end{DoxyNote}
\mbox{\label{filter_8h_a3b942df507e4f9a6d7525e5a4c6864e5}} 
\index{filter.\+h@{filter.\+h}!lzma\+\_\+raw\+\_\+buffer\+\_\+decode@{lzma\+\_\+raw\+\_\+buffer\+\_\+decode}}
\index{lzma\+\_\+raw\+\_\+buffer\+\_\+decode@{lzma\+\_\+raw\+\_\+buffer\+\_\+decode}!filter.\+h@{filter.\+h}}
\subsubsection{lzma\+\_\+raw\+\_\+buffer\+\_\+decode()}
{\footnotesize\ttfamily \textbf{ lzma\+\_\+ret} lzma\+\_\+raw\+\_\+buffer\+\_\+decode (\begin{DoxyParamCaption}\item[{const \textbf{ lzma\+\_\+filter} $\ast$}]{filters,  }\item[{const \textbf{ lzma\+\_\+allocator} $\ast$}]{allocator,  }\item[{const uint8\+\_\+t $\ast$}]{in,  }\item[{size\+\_\+t $\ast$}]{in\+\_\+pos,  }\item[{size\+\_\+t}]{in\+\_\+size,  }\item[{uint8\+\_\+t $\ast$}]{out,  }\item[{size\+\_\+t $\ast$}]{out\+\_\+pos,  }\item[{size\+\_\+t}]{out\+\_\+size }\end{DoxyParamCaption})}



Single-\/call raw decoder. 


\begin{DoxyParams}{Parameters}
{\em filters} & Array of \doxyref{lzma\+\_\+filter}{p.}{structlzma__filter} structures. The end of the array must be marked with .id = L\+Z\+M\+A\+\_\+\+V\+L\+I\+\_\+\+U\+N\+K\+N\+O\+WN. \\
\hline
{\em allocator} & \doxyref{lzma\+\_\+allocator}{p.}{structlzma__allocator} for custom allocator functions. Set to N\+U\+LL to use malloc() and free(). \\
\hline
{\em in} & Beginning of the input buffer \\
\hline
{\em in\+\_\+pos} & The next byte will be read from in[$\ast$in\+\_\+pos]. $\ast$in\+\_\+pos is updated only if decoding succeeds. \\
\hline
{\em in\+\_\+size} & Size of the input buffer; the first byte that won\textquotesingle{}t be read is in[in\+\_\+size]. \\
\hline
{\em out} & Beginning of the output buffer \\
\hline
{\em out\+\_\+pos} & The next byte will be written to out[$\ast$out\+\_\+pos]. $\ast$out\+\_\+pos is updated only if encoding succeeds. \\
\hline
{\em out\+\_\+size} & Size of the out buffer; the first byte into which no data is written to is out[out\+\_\+size]. \\
\hline
\end{DoxyParams}
\mbox{\label{filter_8h_aee038818cf7bbe044c3f7a7c86998c1b}} 
\index{filter.\+h@{filter.\+h}!lzma\+\_\+properties\+\_\+size@{lzma\+\_\+properties\+\_\+size}}
\index{lzma\+\_\+properties\+\_\+size@{lzma\+\_\+properties\+\_\+size}!filter.\+h@{filter.\+h}}
\subsubsection{lzma\+\_\+properties\+\_\+size()}
{\footnotesize\ttfamily \textbf{ lzma\+\_\+ret} lzma\+\_\+properties\+\_\+size (\begin{DoxyParamCaption}\item[{uint32\+\_\+t $\ast$}]{size,  }\item[{const \textbf{ lzma\+\_\+filter} $\ast$}]{filter }\end{DoxyParamCaption})}



Get the size of the Filter Properties field. 

This function may be useful when implementing custom file formats using the raw encoder and decoder.


\begin{DoxyParams}{Parameters}
{\em size} & Pointer to uint32\+\_\+t to hold the size of the properties \\
\hline
{\em filter} & Filter ID and options (the size of the properties may vary depending on the options)\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
-\/ L\+Z\+M\+A\+\_\+\+OK
\begin{DoxyItemize}
\item L\+Z\+M\+A\+\_\+\+O\+P\+T\+I\+O\+N\+S\+\_\+\+E\+R\+R\+OR
\item L\+Z\+M\+A\+\_\+\+P\+R\+O\+G\+\_\+\+E\+R\+R\+OR
\end{DoxyItemize}
\end{DoxyReturn}
\begin{DoxyNote}{Note}
This function validates the Filter ID, but does not necessarily validate the options. Thus, it is possible that this returns L\+Z\+M\+A\+\_\+\+OK while the following call to \doxyref{lzma\+\_\+properties\+\_\+encode()}{p.}{filter_8h_a8e00887086df5a44084ac22e48415de3} returns L\+Z\+M\+A\+\_\+\+O\+P\+T\+I\+O\+N\+S\+\_\+\+E\+R\+R\+OR. 
\end{DoxyNote}


Referenced by lzma\+\_\+filter\+\_\+flags\+\_\+encode(), and lzma\+\_\+filter\+\_\+flags\+\_\+size().

\mbox{\label{filter_8h_a8e00887086df5a44084ac22e48415de3}} 
\index{filter.\+h@{filter.\+h}!lzma\+\_\+properties\+\_\+encode@{lzma\+\_\+properties\+\_\+encode}}
\index{lzma\+\_\+properties\+\_\+encode@{lzma\+\_\+properties\+\_\+encode}!filter.\+h@{filter.\+h}}
\subsubsection{lzma\+\_\+properties\+\_\+encode()}
{\footnotesize\ttfamily \textbf{ lzma\+\_\+ret} lzma\+\_\+properties\+\_\+encode (\begin{DoxyParamCaption}\item[{const \textbf{ lzma\+\_\+filter} $\ast$}]{filter,  }\item[{uint8\+\_\+t $\ast$}]{props }\end{DoxyParamCaption})}



Encode the Filter Properties field. 


\begin{DoxyParams}{Parameters}
{\em filter} & Filter ID and options \\
\hline
{\em props} & Buffer to hold the encoded options. The size of buffer must have been already determined with \doxyref{lzma\+\_\+properties\+\_\+size()}{p.}{filter_8h_aee038818cf7bbe044c3f7a7c86998c1b}.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
-\/ L\+Z\+M\+A\+\_\+\+OK
\begin{DoxyItemize}
\item L\+Z\+M\+A\+\_\+\+O\+P\+T\+I\+O\+N\+S\+\_\+\+E\+R\+R\+OR
\item L\+Z\+M\+A\+\_\+\+P\+R\+O\+G\+\_\+\+E\+R\+R\+OR
\end{DoxyItemize}
\end{DoxyReturn}
\begin{DoxyNote}{Note}
Even this function won\textquotesingle{}t validate more options than actually necessary. Thus, it is possible that encoding the properties succeeds but using the same options to initialize the encoder will fail.

If \doxyref{lzma\+\_\+properties\+\_\+size()}{p.}{filter_8h_aee038818cf7bbe044c3f7a7c86998c1b} indicated that the size of the Filter Properties field is zero, calling \doxyref{lzma\+\_\+properties\+\_\+encode()}{p.}{filter_8h_a8e00887086df5a44084ac22e48415de3} is not required, but it won\textquotesingle{}t do any harm either. 
\end{DoxyNote}


Referenced by lzma\+\_\+filter\+\_\+flags\+\_\+encode().

\mbox{\label{filter_8h_a88d2e864b2039ac82802cc202278d478}} 
\index{filter.\+h@{filter.\+h}!lzma\+\_\+properties\+\_\+decode@{lzma\+\_\+properties\+\_\+decode}}
\index{lzma\+\_\+properties\+\_\+decode@{lzma\+\_\+properties\+\_\+decode}!filter.\+h@{filter.\+h}}
\subsubsection{lzma\+\_\+properties\+\_\+decode()}
{\footnotesize\ttfamily \textbf{ lzma\+\_\+ret} lzma\+\_\+properties\+\_\+decode (\begin{DoxyParamCaption}\item[{\textbf{ lzma\+\_\+filter} $\ast$}]{filter,  }\item[{const \textbf{ lzma\+\_\+allocator} $\ast$}]{allocator,  }\item[{const uint8\+\_\+t $\ast$}]{props,  }\item[{size\+\_\+t}]{props\+\_\+size }\end{DoxyParamCaption})}



Decode the Filter Properties field. 


\begin{DoxyParams}{Parameters}
{\em filter} & filter-\/$>$id must have been set to the correct Filter ID. filter-\/$>$options doesn\textquotesingle{}t need to be initialized (it\textquotesingle{}s not freed by this function). The decoded options will be stored to filter-\/$>$options. filter-\/$>$options is set to N\+U\+LL if there are no properties or if an error occurs. \\
\hline
{\em allocator} & Custom memory allocator used to allocate the options. Set to N\+U\+LL to use the default malloc(), and in case of an error, also free(). \\
\hline
{\em props} & Input buffer containing the properties. \\
\hline
{\em props\+\_\+size} & Size of the properties. This must be the exact size; giving too much or too little input will return L\+Z\+M\+A\+\_\+\+O\+P\+T\+I\+O\+N\+S\+\_\+\+E\+R\+R\+OR.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
-\/ L\+Z\+M\+A\+\_\+\+OK
\begin{DoxyItemize}
\item L\+Z\+M\+A\+\_\+\+O\+P\+T\+I\+O\+N\+S\+\_\+\+E\+R\+R\+OR
\item L\+Z\+M\+A\+\_\+\+M\+E\+M\+\_\+\+E\+R\+R\+OR 
\end{DoxyItemize}
\end{DoxyReturn}
\mbox{\label{filter_8h_a996c9c21840ed54e37bd1f664a79d940}} 
\index{filter.\+h@{filter.\+h}!lzma\+\_\+filter\+\_\+flags\+\_\+size@{lzma\+\_\+filter\+\_\+flags\+\_\+size}}
\index{lzma\+\_\+filter\+\_\+flags\+\_\+size@{lzma\+\_\+filter\+\_\+flags\+\_\+size}!filter.\+h@{filter.\+h}}
\subsubsection{lzma\+\_\+filter\+\_\+flags\+\_\+size()}
{\footnotesize\ttfamily \textbf{ lzma\+\_\+ret} lzma\+\_\+filter\+\_\+flags\+\_\+size (\begin{DoxyParamCaption}\item[{uint32\+\_\+t $\ast$}]{size,  }\item[{const \textbf{ lzma\+\_\+filter} $\ast$}]{filter }\end{DoxyParamCaption})}



Calculate encoded size of a Filter Flags field. 

Knowing the size of Filter Flags is useful to know when allocating memory to hold the encoded Filter Flags.


\begin{DoxyParams}{Parameters}
{\em size} & Pointer to integer to hold the calculated size \\
\hline
{\em filter} & Filter ID and associated options whose encoded size is to be calculated\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
-\/ L\+Z\+M\+A\+\_\+\+OK\+: $\ast$size set successfully. Note that this doesn\textquotesingle{}t guarantee that filter-\/$>$options is valid, thus \doxyref{lzma\+\_\+filter\+\_\+flags\+\_\+encode()}{p.}{filter_8h_a96f23309bc21398fece18c00ebe7db98} may still fail.
\begin{DoxyItemize}
\item L\+Z\+M\+A\+\_\+\+O\+P\+T\+I\+O\+N\+S\+\_\+\+E\+R\+R\+OR\+: Unknown Filter ID or unsupported options.
\item L\+Z\+M\+A\+\_\+\+P\+R\+O\+G\+\_\+\+E\+R\+R\+OR\+: Invalid options
\end{DoxyItemize}
\end{DoxyReturn}
\begin{DoxyNote}{Note}
If you need to calculate size of List of Filter Flags, you need to loop over every \doxyref{lzma\+\_\+filter}{p.}{structlzma__filter} entry. 
\end{DoxyNote}


References L\+Z\+M\+A\+\_\+\+F\+I\+L\+T\+E\+R\+\_\+\+R\+E\+S\+E\+R\+V\+E\+D\+\_\+\+S\+T\+A\+RT, L\+Z\+M\+A\+\_\+\+OK, L\+Z\+M\+A\+\_\+\+P\+R\+O\+G\+\_\+\+E\+R\+R\+OR, lzma\+\_\+properties\+\_\+size(), lzma\+\_\+vli\+\_\+size(), and return\+\_\+if\+\_\+error.



Referenced by lzma\+\_\+block\+\_\+header\+\_\+size().

\mbox{\label{filter_8h_a96f23309bc21398fece18c00ebe7db98}} 
\index{filter.\+h@{filter.\+h}!lzma\+\_\+filter\+\_\+flags\+\_\+encode@{lzma\+\_\+filter\+\_\+flags\+\_\+encode}}
\index{lzma\+\_\+filter\+\_\+flags\+\_\+encode@{lzma\+\_\+filter\+\_\+flags\+\_\+encode}!filter.\+h@{filter.\+h}}
\subsubsection{lzma\+\_\+filter\+\_\+flags\+\_\+encode()}
{\footnotesize\ttfamily \textbf{ lzma\+\_\+ret} lzma\+\_\+filter\+\_\+flags\+\_\+encode (\begin{DoxyParamCaption}\item[{const \textbf{ lzma\+\_\+filter} $\ast$}]{filter,  }\item[{uint8\+\_\+t $\ast$}]{out,  }\item[{size\+\_\+t $\ast$}]{out\+\_\+pos,  }\item[{size\+\_\+t}]{out\+\_\+size }\end{DoxyParamCaption})}



Encode Filter Flags into given buffer. 

In contrast to some functions, this doesn\textquotesingle{}t allocate the needed buffer. This is due to how this function is used internally by liblzma.


\begin{DoxyParams}{Parameters}
{\em filter} & Filter ID and options to be encoded \\
\hline
{\em out} & Beginning of the output buffer \\
\hline
{\em out\+\_\+pos} & out[$\ast$out\+\_\+pos] is the next write position. This is updated by the encoder. \\
\hline
{\em out\+\_\+size} & out[out\+\_\+size] is the first byte to not write.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
-\/ L\+Z\+M\+A\+\_\+\+OK\+: Encoding was successful.
\begin{DoxyItemize}
\item L\+Z\+M\+A\+\_\+\+O\+P\+T\+I\+O\+N\+S\+\_\+\+E\+R\+R\+OR\+: Invalid or unsupported options.
\item L\+Z\+M\+A\+\_\+\+P\+R\+O\+G\+\_\+\+E\+R\+R\+OR\+: Invalid options or not enough output buffer space (you should have checked it with \doxyref{lzma\+\_\+filter\+\_\+flags\+\_\+size()}{p.}{filter_8h_a996c9c21840ed54e37bd1f664a79d940}). 
\end{DoxyItemize}
\end{DoxyReturn}


References L\+Z\+M\+A\+\_\+\+F\+I\+L\+T\+E\+R\+\_\+\+R\+E\+S\+E\+R\+V\+E\+D\+\_\+\+S\+T\+A\+RT, L\+Z\+M\+A\+\_\+\+OK, L\+Z\+M\+A\+\_\+\+P\+R\+O\+G\+\_\+\+E\+R\+R\+OR, lzma\+\_\+properties\+\_\+encode(), lzma\+\_\+properties\+\_\+size(), lzma\+\_\+vli\+\_\+encode(), and return\+\_\+if\+\_\+error.



Referenced by lzma\+\_\+block\+\_\+header\+\_\+encode().

\mbox{\label{filter_8h_a4cba9a4c658cce0ff01fd102b31ea1a7}} 
\index{filter.\+h@{filter.\+h}!lzma\+\_\+filter\+\_\+flags\+\_\+decode@{lzma\+\_\+filter\+\_\+flags\+\_\+decode}}
\index{lzma\+\_\+filter\+\_\+flags\+\_\+decode@{lzma\+\_\+filter\+\_\+flags\+\_\+decode}!filter.\+h@{filter.\+h}}
\subsubsection{lzma\+\_\+filter\+\_\+flags\+\_\+decode()}
{\footnotesize\ttfamily \textbf{ lzma\+\_\+ret} lzma\+\_\+filter\+\_\+flags\+\_\+decode (\begin{DoxyParamCaption}\item[{\textbf{ lzma\+\_\+filter} $\ast$}]{filter,  }\item[{const \textbf{ lzma\+\_\+allocator} $\ast$}]{allocator,  }\item[{const uint8\+\_\+t $\ast$}]{in,  }\item[{size\+\_\+t $\ast$}]{in\+\_\+pos,  }\item[{size\+\_\+t}]{in\+\_\+size }\end{DoxyParamCaption})}



Decode Filter Flags from given buffer. 

The decoded result is stored into $\ast$filter. The old value of filter-\/$>$options is not free()d.

\begin{DoxyReturn}{Returns}
-\/ L\+Z\+M\+A\+\_\+\+OK
\begin{DoxyItemize}
\item L\+Z\+M\+A\+\_\+\+O\+P\+T\+I\+O\+N\+S\+\_\+\+E\+R\+R\+OR
\item L\+Z\+M\+A\+\_\+\+M\+E\+M\+\_\+\+E\+R\+R\+OR
\item L\+Z\+M\+A\+\_\+\+P\+R\+O\+G\+\_\+\+E\+R\+R\+OR 
\end{DoxyItemize}
\end{DoxyReturn}
