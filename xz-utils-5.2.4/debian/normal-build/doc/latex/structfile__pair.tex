\section{file\+\_\+pair Struct Reference}
\label{structfile__pair}\index{file\+\_\+pair@{file\+\_\+pair}}
\subsection*{Data Fields}
\begin{DoxyCompactItemize}
\item 
const char $\ast$ \textbf{ src\+\_\+name}
\item 
char $\ast$ \textbf{ dest\+\_\+name}
\item 
int \textbf{ src\+\_\+fd}
\begin{DoxyCompactList}\small\item\em File descriptor of the source file. \end{DoxyCompactList}\item 
int \textbf{ dest\+\_\+fd}
\begin{DoxyCompactList}\small\item\em File descriptor of the target file. \end{DoxyCompactList}\item 
bool \textbf{ src\+\_\+eof}
\begin{DoxyCompactList}\small\item\em True once end of the source file has been detected. \end{DoxyCompactList}\item 
bool \textbf{ dest\+\_\+try\+\_\+sparse}
\item 
off\+\_\+t \textbf{ dest\+\_\+pending\+\_\+sparse}
\item 
struct stat \textbf{ src\+\_\+st}
\begin{DoxyCompactList}\small\item\em Stat of the source file. \end{DoxyCompactList}\item 
struct stat \textbf{ dest\+\_\+st}
\begin{DoxyCompactList}\small\item\em Stat of the destination file. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Field Documentation}
\mbox{\label{structfile__pair_abcd6b5b852a5bc8815a44dd025113bcf}} 
\index{file\+\_\+pair@{file\+\_\+pair}!src\+\_\+name@{src\+\_\+name}}
\index{src\+\_\+name@{src\+\_\+name}!file\+\_\+pair@{file\+\_\+pair}}
\subsubsection{src\+\_\+name}
{\footnotesize\ttfamily const char$\ast$ file\+\_\+pair\+::src\+\_\+name}

Name of the source filename (as given on the command line) or pointer to static \char`\"{}(stdin)\char`\"{} when reading from standard input. 

Referenced by io\+\_\+open\+\_\+src(), and io\+\_\+open\+\_\+src\+\_\+real().

\mbox{\label{structfile__pair_a7f1b46a8a665881ffa22d2d7b33b91ed}} 
\index{file\+\_\+pair@{file\+\_\+pair}!dest\+\_\+name@{dest\+\_\+name}}
\index{dest\+\_\+name@{dest\+\_\+name}!file\+\_\+pair@{file\+\_\+pair}}
\subsubsection{dest\+\_\+name}
{\footnotesize\ttfamily char$\ast$ file\+\_\+pair\+::dest\+\_\+name}

Destination filename converted from src\+\_\+name or pointer to static \char`\"{}(stdout)\char`\"{} when writing to standard output. \mbox{\label{structfile__pair_acbab9ee46b39f49a7996360ae6dbe0a4}} 
\index{file\+\_\+pair@{file\+\_\+pair}!src\+\_\+fd@{src\+\_\+fd}}
\index{src\+\_\+fd@{src\+\_\+fd}!file\+\_\+pair@{file\+\_\+pair}}
\subsubsection{src\+\_\+fd}
{\footnotesize\ttfamily int file\+\_\+pair\+::src\+\_\+fd}



File descriptor of the source file. 



Referenced by io\+\_\+open\+\_\+src(), io\+\_\+pread(), and io\+\_\+wait().

\mbox{\label{structfile__pair_a95b05b836e2abd7cb9b227f03dcb5492}} 
\index{file\+\_\+pair@{file\+\_\+pair}!dest\+\_\+fd@{dest\+\_\+fd}}
\index{dest\+\_\+fd@{dest\+\_\+fd}!file\+\_\+pair@{file\+\_\+pair}}
\subsubsection{dest\+\_\+fd}
{\footnotesize\ttfamily int file\+\_\+pair\+::dest\+\_\+fd}



File descriptor of the target file. 



Referenced by io\+\_\+close(), io\+\_\+copy\+\_\+attrs(), and io\+\_\+wait().

\mbox{\label{structfile__pair_afee08cdab4c8f19e0734a6da48e21921}} 
\index{file\+\_\+pair@{file\+\_\+pair}!src\+\_\+eof@{src\+\_\+eof}}
\index{src\+\_\+eof@{src\+\_\+eof}!file\+\_\+pair@{file\+\_\+pair}}
\subsubsection{src\+\_\+eof}
{\footnotesize\ttfamily bool file\+\_\+pair\+::src\+\_\+eof}



True once end of the source file has been detected. 



Referenced by coder\+\_\+normal().

\mbox{\label{structfile__pair_a0267a1a379d041c2c4dbf6db1035a20c}} 
\index{file\+\_\+pair@{file\+\_\+pair}!dest\+\_\+try\+\_\+sparse@{dest\+\_\+try\+\_\+sparse}}
\index{dest\+\_\+try\+\_\+sparse@{dest\+\_\+try\+\_\+sparse}!file\+\_\+pair@{file\+\_\+pair}}
\subsubsection{dest\+\_\+try\+\_\+sparse}
{\footnotesize\ttfamily bool file\+\_\+pair\+::dest\+\_\+try\+\_\+sparse}

If true, we look for long chunks of zeros and try to create a sparse file. 

Referenced by io\+\_\+close().

\mbox{\label{structfile__pair_a8372ad2043ad566b72c2743bd42bbe22}} 
\index{file\+\_\+pair@{file\+\_\+pair}!dest\+\_\+pending\+\_\+sparse@{dest\+\_\+pending\+\_\+sparse}}
\index{dest\+\_\+pending\+\_\+sparse@{dest\+\_\+pending\+\_\+sparse}!file\+\_\+pair@{file\+\_\+pair}}
\subsubsection{dest\+\_\+pending\+\_\+sparse}
{\footnotesize\ttfamily off\+\_\+t file\+\_\+pair\+::dest\+\_\+pending\+\_\+sparse}

This is used only if dest\+\_\+try\+\_\+sparse is true. This holds the number of zero bytes we haven\textquotesingle{}t written out, because we plan to make that byte range a sparse chunk. 

Referenced by io\+\_\+close().

\mbox{\label{structfile__pair_ab2b63e4c15c0489b67ee3d795174d3dc}} 
\index{file\+\_\+pair@{file\+\_\+pair}!src\+\_\+st@{src\+\_\+st}}
\index{src\+\_\+st@{src\+\_\+st}!file\+\_\+pair@{file\+\_\+pair}}
\subsubsection{src\+\_\+st}
{\footnotesize\ttfamily struct stat file\+\_\+pair\+::src\+\_\+st}



Stat of the source file. 



Referenced by io\+\_\+copy\+\_\+attrs(), and parse\+\_\+indexes().

\mbox{\label{structfile__pair_a31c3f2a5ea5d9538c4e29398c535a183}} 
\index{file\+\_\+pair@{file\+\_\+pair}!dest\+\_\+st@{dest\+\_\+st}}
\index{dest\+\_\+st@{dest\+\_\+st}!file\+\_\+pair@{file\+\_\+pair}}
\subsubsection{dest\+\_\+st}
{\footnotesize\ttfamily struct stat file\+\_\+pair\+::dest\+\_\+st}



Stat of the destination file. 



The documentation for this struct was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
xz/\textbf{ file\+\_\+io.\+h}\end{DoxyCompactItemize}
