\section{liblzma/common/index\+\_\+encoder.c File Reference}
\label{index__encoder_8c}\index{liblzma/common/index\+\_\+encoder.\+c@{liblzma/common/index\+\_\+encoder.\+c}}


Encodes the Index field.  


{\ttfamily \#include \char`\"{}index\+\_\+encoder.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}index.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}check.\+h\char`\"{}}\newline
\subsection*{Data Structures}
\begin{DoxyCompactItemize}
\item 
struct \textbf{ lzma\+\_\+index\+\_\+coder}
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\label{index__encoder_8c_a31c058c46a7ae24de69f7f47a9fd1360}} 
static \textbf{ lzma\+\_\+ret} {\bfseries index\+\_\+encode} (void $\ast$coder\+\_\+ptr, const \textbf{ lzma\+\_\+allocator} $\ast$allocator \textbf{ lzma\+\_\+attribute}((\+\_\+\+\_\+unused\+\_\+\+\_\+)), const uint8\+\_\+t $\ast$restrict in \textbf{ lzma\+\_\+attribute}((\+\_\+\+\_\+unused\+\_\+\+\_\+)), size\+\_\+t $\ast$restrict in\+\_\+pos \textbf{ lzma\+\_\+attribute}((\+\_\+\+\_\+unused\+\_\+\+\_\+)), size\+\_\+t in\+\_\+size \textbf{ lzma\+\_\+attribute}((\+\_\+\+\_\+unused\+\_\+\+\_\+)), uint8\+\_\+t $\ast$restrict out, size\+\_\+t $\ast$restrict out\+\_\+pos, size\+\_\+t out\+\_\+size, \textbf{ lzma\+\_\+action} action \textbf{ lzma\+\_\+attribute}((\+\_\+\+\_\+unused\+\_\+\+\_\+)))
\item 
\mbox{\label{index__encoder_8c_aec074caae4af9ca99c525435ce5deeef}} 
static void {\bfseries index\+\_\+encoder\+\_\+end} (void $\ast$coder, const \textbf{ lzma\+\_\+allocator} $\ast$allocator)
\item 
\mbox{\label{index__encoder_8c_a971e34be7459817d557ea60c0e927a0f}} 
static void {\bfseries index\+\_\+encoder\+\_\+reset} (\textbf{ lzma\+\_\+index\+\_\+coder} $\ast$coder, const \textbf{ lzma\+\_\+index} $\ast$i)
\item 
\mbox{\label{index__encoder_8c_a642c8652ed91df92d0be729d76ddb743}} 
\textbf{ lzma\+\_\+ret} {\bfseries lzma\+\_\+index\+\_\+encoder\+\_\+init} (\textbf{ lzma\+\_\+next\+\_\+coder} $\ast$next, const \textbf{ lzma\+\_\+allocator} $\ast$allocator, const \textbf{ lzma\+\_\+index} $\ast$i)
\item 
\textbf{ lzma\+\_\+ret} \textbf{ lzma\+\_\+index\+\_\+encoder} (\textbf{ lzma\+\_\+stream} $\ast$\textbf{ strm}, const \textbf{ lzma\+\_\+index} $\ast$i)
\begin{DoxyCompactList}\small\item\em Initialize .xz Index encoder. \end{DoxyCompactList}\item 
\textbf{ lzma\+\_\+ret} \textbf{ lzma\+\_\+index\+\_\+buffer\+\_\+encode} (const \textbf{ lzma\+\_\+index} $\ast$i, uint8\+\_\+t $\ast$out, size\+\_\+t $\ast$out\+\_\+pos, size\+\_\+t out\+\_\+size)
\begin{DoxyCompactList}\small\item\em Single-\/call .xz Index encoder. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
Encodes the Index field. 



\subsection{Function Documentation}
\mbox{\label{index__encoder_8c_ad1398e64633414d8f50e6ae5432958e2}} 
\index{index\+\_\+encoder.\+c@{index\+\_\+encoder.\+c}!lzma\+\_\+index\+\_\+encoder@{lzma\+\_\+index\+\_\+encoder}}
\index{lzma\+\_\+index\+\_\+encoder@{lzma\+\_\+index\+\_\+encoder}!index\+\_\+encoder.\+c@{index\+\_\+encoder.\+c}}
\subsubsection{lzma\+\_\+index\+\_\+encoder()}
{\footnotesize\ttfamily \textbf{ lzma\+\_\+ret} lzma\+\_\+index\+\_\+encoder (\begin{DoxyParamCaption}\item[{\textbf{ lzma\+\_\+stream} $\ast$}]{strm,  }\item[{const \textbf{ lzma\+\_\+index} $\ast$}]{i }\end{DoxyParamCaption})}



Initialize .xz Index encoder. 


\begin{DoxyParams}{Parameters}
{\em strm} & Pointer to properly prepared \doxyref{lzma\+\_\+stream}{p.}{structlzma__stream} \\
\hline
{\em i} & Pointer to lzma\+\_\+index which should be encoded.\\
\hline
\end{DoxyParams}
The valid `action\textquotesingle{} values for \doxyref{lzma\+\_\+code()}{p.}{base_8h_a28cc09bc422d5ba1e0187c9f2af5d957} are L\+Z\+M\+A\+\_\+\+R\+UN and L\+Z\+M\+A\+\_\+\+F\+I\+N\+I\+SH. It is enough to use only one of them (you can choose freely).

\begin{DoxyReturn}{Returns}
-\/ L\+Z\+M\+A\+\_\+\+OK\+: Initialization succeeded, continue with \doxyref{lzma\+\_\+code()}{p.}{base_8h_a28cc09bc422d5ba1e0187c9f2af5d957}.
\begin{DoxyItemize}
\item L\+Z\+M\+A\+\_\+\+M\+E\+M\+\_\+\+E\+R\+R\+OR
\item L\+Z\+M\+A\+\_\+\+P\+R\+O\+G\+\_\+\+E\+R\+R\+OR 
\end{DoxyItemize}
\end{DoxyReturn}


References lzma\+\_\+next\+\_\+strm\+\_\+init.

\mbox{\label{index__encoder_8c_a9a6a4b09464a3edc101ff4f4b1f49917}} 
\index{index\+\_\+encoder.\+c@{index\+\_\+encoder.\+c}!lzma\+\_\+index\+\_\+buffer\+\_\+encode@{lzma\+\_\+index\+\_\+buffer\+\_\+encode}}
\index{lzma\+\_\+index\+\_\+buffer\+\_\+encode@{lzma\+\_\+index\+\_\+buffer\+\_\+encode}!index\+\_\+encoder.\+c@{index\+\_\+encoder.\+c}}
\subsubsection{lzma\+\_\+index\+\_\+buffer\+\_\+encode()}
{\footnotesize\ttfamily \textbf{ lzma\+\_\+ret} lzma\+\_\+index\+\_\+buffer\+\_\+encode (\begin{DoxyParamCaption}\item[{const \textbf{ lzma\+\_\+index} $\ast$}]{i,  }\item[{uint8\+\_\+t $\ast$}]{out,  }\item[{size\+\_\+t $\ast$}]{out\+\_\+pos,  }\item[{size\+\_\+t}]{out\+\_\+size }\end{DoxyParamCaption})}



Single-\/call .xz Index encoder. 


\begin{DoxyParams}{Parameters}
{\em i} & lzma\+\_\+index to be encoded \\
\hline
{\em out} & Beginning of the output buffer \\
\hline
{\em out\+\_\+pos} & The next byte will be written to out[$\ast$out\+\_\+pos]. $\ast$out\+\_\+pos is updated only if encoding succeeds. \\
\hline
{\em out\+\_\+size} & Size of the out buffer; the first byte into which no data is written to is out[out\+\_\+size].\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
-\/ L\+Z\+M\+A\+\_\+\+OK\+: Encoding was successful.
\begin{DoxyItemize}
\item L\+Z\+M\+A\+\_\+\+B\+U\+F\+\_\+\+E\+R\+R\+OR\+: Output buffer is too small. Use \doxyref{lzma\+\_\+index\+\_\+size()}{p.}{api_2lzma_2index_8h_a669ed1a82b1941217cfbb07e7826afc2} to find out how much output space is needed.
\item L\+Z\+M\+A\+\_\+\+P\+R\+O\+G\+\_\+\+E\+R\+R\+OR
\end{DoxyItemize}
\end{DoxyReturn}
\begin{DoxyNote}{Note}
This function doesn\textquotesingle{}t take allocator argument since all the internal data is allocated on stack. 
\end{DoxyNote}


References L\+Z\+M\+A\+\_\+\+B\+U\+F\+\_\+\+E\+R\+R\+OR, lzma\+\_\+index\+\_\+size(), and L\+Z\+M\+A\+\_\+\+P\+R\+O\+G\+\_\+\+E\+R\+R\+OR.

