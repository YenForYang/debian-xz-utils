\section{liblzma/api/lzma/index.h File Reference}
\label{api_2lzma_2index_8h}\index{liblzma/api/lzma/index.\+h@{liblzma/api/lzma/index.\+h}}


Handling of .xz Index and related information.  


\subsection*{Data Structures}
\begin{DoxyCompactItemize}
\item 
struct \textbf{ lzma\+\_\+index\+\_\+iter}
\begin{DoxyCompactList}\small\item\em Iterator to get information about Blocks and Streams. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
typedef struct \textbf{ lzma\+\_\+index\+\_\+s} \textbf{ lzma\+\_\+index}
\begin{DoxyCompactList}\small\item\em Opaque data type to hold the Index(es) and other information. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Enumerations}
\begin{DoxyCompactItemize}
\item 
enum \textbf{ lzma\+\_\+index\+\_\+iter\+\_\+mode} \{ \textbf{ L\+Z\+M\+A\+\_\+\+I\+N\+D\+E\+X\+\_\+\+I\+T\+E\+R\+\_\+\+A\+NY} = 0, 
\textbf{ L\+Z\+M\+A\+\_\+\+I\+N\+D\+E\+X\+\_\+\+I\+T\+E\+R\+\_\+\+S\+T\+R\+E\+AM} = 1, 
\textbf{ L\+Z\+M\+A\+\_\+\+I\+N\+D\+E\+X\+\_\+\+I\+T\+E\+R\+\_\+\+B\+L\+O\+CK} = 2, 
\textbf{ L\+Z\+M\+A\+\_\+\+I\+N\+D\+E\+X\+\_\+\+I\+T\+E\+R\+\_\+\+N\+O\+N\+E\+M\+P\+T\+Y\+\_\+\+B\+L\+O\+CK} = 3
 \}\begin{DoxyCompactList}\small\item\em Operation mode for \doxyref{lzma\+\_\+index\+\_\+iter\+\_\+next()}{p.}{api_2lzma_2index_8h_af428522e1b3eef137c65c5a01f766e0e} \end{DoxyCompactList}
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
uint64\+\_\+t \textbf{ lzma\+\_\+index\+\_\+memusage} (\textbf{ lzma\+\_\+vli} streams, \textbf{ lzma\+\_\+vli} blocks) lzma\+\_\+nothrow
\begin{DoxyCompactList}\small\item\em Calculate memory usage of lzma\+\_\+index. \end{DoxyCompactList}\item 
uint64\+\_\+t \textbf{ lzma\+\_\+index\+\_\+memused} (const \textbf{ lzma\+\_\+index} $\ast$i) lzma\+\_\+nothrow
\begin{DoxyCompactList}\small\item\em Calculate the memory usage of an existing lzma\+\_\+index. \end{DoxyCompactList}\item 
\textbf{ lzma\+\_\+index} $\ast$ \textbf{ lzma\+\_\+index\+\_\+init} (const \textbf{ lzma\+\_\+allocator} $\ast$allocator) lzma\+\_\+nothrow
\begin{DoxyCompactList}\small\item\em Allocate and initialize a new lzma\+\_\+index structure. \end{DoxyCompactList}\item 
void \textbf{ lzma\+\_\+index\+\_\+end} (\textbf{ lzma\+\_\+index} $\ast$i, const \textbf{ lzma\+\_\+allocator} $\ast$allocator) lzma\+\_\+nothrow
\begin{DoxyCompactList}\small\item\em Deallocate lzma\+\_\+index. \end{DoxyCompactList}\item 
\textbf{ lzma\+\_\+ret} \textbf{ lzma\+\_\+index\+\_\+append} (\textbf{ lzma\+\_\+index} $\ast$i, const \textbf{ lzma\+\_\+allocator} $\ast$allocator, \textbf{ lzma\+\_\+vli} unpadded\+\_\+size, \textbf{ lzma\+\_\+vli} uncompressed\+\_\+size) lzma\+\_\+nothrow lzma\+\_\+attr\+\_\+warn\+\_\+unused\+\_\+result
\begin{DoxyCompactList}\small\item\em Add a new Block to lzma\+\_\+index. \end{DoxyCompactList}\item 
\textbf{ lzma\+\_\+ret} \textbf{ lzma\+\_\+index\+\_\+stream\+\_\+flags} (\textbf{ lzma\+\_\+index} $\ast$i, const \textbf{ lzma\+\_\+stream\+\_\+flags} $\ast$stream\+\_\+flags) lzma\+\_\+nothrow lzma\+\_\+attr\+\_\+warn\+\_\+unused\+\_\+result
\begin{DoxyCompactList}\small\item\em Set the Stream Flags. \end{DoxyCompactList}\item 
uint32\+\_\+t \textbf{ lzma\+\_\+index\+\_\+checks} (const \textbf{ lzma\+\_\+index} $\ast$i) lzma\+\_\+nothrow lzma\+\_\+attr\+\_\+pure
\begin{DoxyCompactList}\small\item\em Get the types of integrity Checks. \end{DoxyCompactList}\item 
\textbf{ lzma\+\_\+ret} \textbf{ lzma\+\_\+index\+\_\+stream\+\_\+padding} (\textbf{ lzma\+\_\+index} $\ast$i, \textbf{ lzma\+\_\+vli} stream\+\_\+padding) lzma\+\_\+nothrow lzma\+\_\+attr\+\_\+warn\+\_\+unused\+\_\+result
\begin{DoxyCompactList}\small\item\em Set the amount of Stream Padding. \end{DoxyCompactList}\item 
\textbf{ lzma\+\_\+vli} \textbf{ lzma\+\_\+index\+\_\+stream\+\_\+count} (const \textbf{ lzma\+\_\+index} $\ast$i) lzma\+\_\+nothrow lzma\+\_\+attr\+\_\+pure
\begin{DoxyCompactList}\small\item\em Get the number of Streams. \end{DoxyCompactList}\item 
\textbf{ lzma\+\_\+vli} \textbf{ lzma\+\_\+index\+\_\+block\+\_\+count} (const \textbf{ lzma\+\_\+index} $\ast$i) lzma\+\_\+nothrow lzma\+\_\+attr\+\_\+pure
\begin{DoxyCompactList}\small\item\em Get the number of Blocks. \end{DoxyCompactList}\item 
\textbf{ lzma\+\_\+vli} \textbf{ lzma\+\_\+index\+\_\+size} (const \textbf{ lzma\+\_\+index} $\ast$i) lzma\+\_\+nothrow lzma\+\_\+attr\+\_\+pure
\begin{DoxyCompactList}\small\item\em Get the size of the Index field as bytes. \end{DoxyCompactList}\item 
\textbf{ lzma\+\_\+vli} \textbf{ lzma\+\_\+index\+\_\+stream\+\_\+size} (const \textbf{ lzma\+\_\+index} $\ast$i) lzma\+\_\+nothrow lzma\+\_\+attr\+\_\+pure
\begin{DoxyCompactList}\small\item\em Get the total size of the Stream. \end{DoxyCompactList}\item 
\textbf{ lzma\+\_\+vli} \textbf{ lzma\+\_\+index\+\_\+total\+\_\+size} (const \textbf{ lzma\+\_\+index} $\ast$i) lzma\+\_\+nothrow lzma\+\_\+attr\+\_\+pure
\begin{DoxyCompactList}\small\item\em Get the total size of the Blocks. \end{DoxyCompactList}\item 
\textbf{ lzma\+\_\+vli} \textbf{ lzma\+\_\+index\+\_\+file\+\_\+size} (const \textbf{ lzma\+\_\+index} $\ast$i) lzma\+\_\+nothrow lzma\+\_\+attr\+\_\+pure
\begin{DoxyCompactList}\small\item\em Get the total size of the file. \end{DoxyCompactList}\item 
\textbf{ lzma\+\_\+vli} \textbf{ lzma\+\_\+index\+\_\+uncompressed\+\_\+size} (const \textbf{ lzma\+\_\+index} $\ast$i) lzma\+\_\+nothrow lzma\+\_\+attr\+\_\+pure
\begin{DoxyCompactList}\small\item\em Get the uncompressed size of the file. \end{DoxyCompactList}\item 
void \textbf{ lzma\+\_\+index\+\_\+iter\+\_\+init} (\textbf{ lzma\+\_\+index\+\_\+iter} $\ast$iter, const \textbf{ lzma\+\_\+index} $\ast$i) lzma\+\_\+nothrow
\begin{DoxyCompactList}\small\item\em Initialize an iterator. \end{DoxyCompactList}\item 
void \textbf{ lzma\+\_\+index\+\_\+iter\+\_\+rewind} (\textbf{ lzma\+\_\+index\+\_\+iter} $\ast$iter) lzma\+\_\+nothrow
\begin{DoxyCompactList}\small\item\em Rewind the iterator. \end{DoxyCompactList}\item 
\textbf{ lzma\+\_\+bool} \textbf{ lzma\+\_\+index\+\_\+iter\+\_\+next} (\textbf{ lzma\+\_\+index\+\_\+iter} $\ast$iter, \textbf{ lzma\+\_\+index\+\_\+iter\+\_\+mode} mode) lzma\+\_\+nothrow lzma\+\_\+attr\+\_\+warn\+\_\+unused\+\_\+result
\begin{DoxyCompactList}\small\item\em Get the next Block or Stream. \end{DoxyCompactList}\item 
\textbf{ lzma\+\_\+bool} \textbf{ lzma\+\_\+index\+\_\+iter\+\_\+locate} (\textbf{ lzma\+\_\+index\+\_\+iter} $\ast$iter, \textbf{ lzma\+\_\+vli} target) lzma\+\_\+nothrow
\begin{DoxyCompactList}\small\item\em Locate a Block. \end{DoxyCompactList}\item 
\textbf{ lzma\+\_\+ret} \textbf{ lzma\+\_\+index\+\_\+cat} (\textbf{ lzma\+\_\+index} $\ast$dest, \textbf{ lzma\+\_\+index} $\ast$src, const \textbf{ lzma\+\_\+allocator} $\ast$allocator) lzma\+\_\+nothrow lzma\+\_\+attr\+\_\+warn\+\_\+unused\+\_\+result
\begin{DoxyCompactList}\small\item\em Concatenate lzma\+\_\+indexes. \end{DoxyCompactList}\item 
\textbf{ lzma\+\_\+index} $\ast$ \textbf{ lzma\+\_\+index\+\_\+dup} (const \textbf{ lzma\+\_\+index} $\ast$i, const \textbf{ lzma\+\_\+allocator} $\ast$allocator) lzma\+\_\+nothrow lzma\+\_\+attr\+\_\+warn\+\_\+unused\+\_\+result
\begin{DoxyCompactList}\small\item\em Duplicate lzma\+\_\+index. \end{DoxyCompactList}\item 
\textbf{ lzma\+\_\+ret} \textbf{ lzma\+\_\+index\+\_\+encoder} (\textbf{ lzma\+\_\+stream} $\ast$\textbf{ strm}, const \textbf{ lzma\+\_\+index} $\ast$i) lzma\+\_\+nothrow lzma\+\_\+attr\+\_\+warn\+\_\+unused\+\_\+result
\begin{DoxyCompactList}\small\item\em Initialize .xz Index encoder. \end{DoxyCompactList}\item 
\textbf{ lzma\+\_\+ret} \textbf{ lzma\+\_\+index\+\_\+decoder} (\textbf{ lzma\+\_\+stream} $\ast$\textbf{ strm}, \textbf{ lzma\+\_\+index} $\ast$$\ast$i, uint64\+\_\+t memlimit) lzma\+\_\+nothrow lzma\+\_\+attr\+\_\+warn\+\_\+unused\+\_\+result
\begin{DoxyCompactList}\small\item\em Initialize .xz Index decoder. \end{DoxyCompactList}\item 
\textbf{ lzma\+\_\+ret} \textbf{ lzma\+\_\+index\+\_\+buffer\+\_\+encode} (const \textbf{ lzma\+\_\+index} $\ast$i, uint8\+\_\+t $\ast$out, size\+\_\+t $\ast$out\+\_\+pos, size\+\_\+t out\+\_\+size) lzma\+\_\+nothrow
\begin{DoxyCompactList}\small\item\em Single-\/call .xz Index encoder. \end{DoxyCompactList}\item 
\textbf{ lzma\+\_\+ret} \textbf{ lzma\+\_\+index\+\_\+buffer\+\_\+decode} (\textbf{ lzma\+\_\+index} $\ast$$\ast$i, uint64\+\_\+t $\ast$memlimit, const \textbf{ lzma\+\_\+allocator} $\ast$allocator, const uint8\+\_\+t $\ast$in, size\+\_\+t $\ast$in\+\_\+pos, size\+\_\+t in\+\_\+size) lzma\+\_\+nothrow
\begin{DoxyCompactList}\small\item\em Single-\/call .xz Index decoder. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
Handling of .xz Index and related information. 



\subsection{Typedef Documentation}
\mbox{\label{api_2lzma_2index_8h_afc18c1443b3b9aa0d146b44e8755b62e}} 
\index{api/lzma/index.\+h@{api/lzma/index.\+h}!lzma\+\_\+index@{lzma\+\_\+index}}
\index{lzma\+\_\+index@{lzma\+\_\+index}!api/lzma/index.\+h@{api/lzma/index.\+h}}
\subsubsection{lzma\+\_\+index}
{\footnotesize\ttfamily typedef struct \textbf{ lzma\+\_\+index\+\_\+s} \textbf{ lzma\+\_\+index}}



Opaque data type to hold the Index(es) and other information. 

lzma\+\_\+index often holds just one .xz Index and possibly the Stream Flags of the same Stream and size of the Stream Padding field. However, multiple lzma\+\_\+indexes can be concatenated with \doxyref{lzma\+\_\+index\+\_\+cat()}{p.}{api_2lzma_2index_8h_abc4db36b4bd67af01819be9dd045c34a} and then there may be information about multiple Streams in the same lzma\+\_\+index.

Notes about thread safety\+: Only one thread may modify lzma\+\_\+index at a time. All functions that take non-\/const pointer to lzma\+\_\+index modify it. As long as no thread is modifying the lzma\+\_\+index, getting information from the same lzma\+\_\+index can be done from multiple threads at the same time with functions that take a const pointer to lzma\+\_\+index or use \doxyref{lzma\+\_\+index\+\_\+iter}{p.}{structlzma__index__iter}. The same iterator must be used only by one thread at a time, of course, but there can be as many iterators for the same lzma\+\_\+index as needed. 

\subsection{Enumeration Type Documentation}
\mbox{\label{api_2lzma_2index_8h_a712b43192d944bf2f767711343cd9ca8}} 
\index{api/lzma/index.\+h@{api/lzma/index.\+h}!lzma\+\_\+index\+\_\+iter\+\_\+mode@{lzma\+\_\+index\+\_\+iter\+\_\+mode}}
\index{lzma\+\_\+index\+\_\+iter\+\_\+mode@{lzma\+\_\+index\+\_\+iter\+\_\+mode}!api/lzma/index.\+h@{api/lzma/index.\+h}}
\subsubsection{lzma\+\_\+index\+\_\+iter\+\_\+mode}
{\footnotesize\ttfamily enum \textbf{ lzma\+\_\+index\+\_\+iter\+\_\+mode}}



Operation mode for \doxyref{lzma\+\_\+index\+\_\+iter\+\_\+next()}{p.}{api_2lzma_2index_8h_af428522e1b3eef137c65c5a01f766e0e} 

\begin{DoxyEnumFields}{Enumerator}
\raisebox{\heightof{T}}[0pt][0pt]{\index{L\+Z\+M\+A\+\_\+\+I\+N\+D\+E\+X\+\_\+\+I\+T\+E\+R\+\_\+\+A\+NY@{L\+Z\+M\+A\+\_\+\+I\+N\+D\+E\+X\+\_\+\+I\+T\+E\+R\+\_\+\+A\+NY}!api/lzma/index.\+h@{api/lzma/index.\+h}}\index{api/lzma/index.\+h@{api/lzma/index.\+h}!L\+Z\+M\+A\+\_\+\+I\+N\+D\+E\+X\+\_\+\+I\+T\+E\+R\+\_\+\+A\+NY@{L\+Z\+M\+A\+\_\+\+I\+N\+D\+E\+X\+\_\+\+I\+T\+E\+R\+\_\+\+A\+NY}}}\mbox{\label{api_2lzma_2index_8h_a712b43192d944bf2f767711343cd9ca8af46f6e5c414471c7c96586f380e48315}} 
L\+Z\+M\+A\+\_\+\+I\+N\+D\+E\+X\+\_\+\+I\+T\+E\+R\+\_\+\+A\+NY&Get the next Block or Stream. Go to the next Block if the current Stream has at least one Block left. Otherwise go to the next Stream even if it has no Blocks. If the Stream has no Blocks (lzma\+\_\+index\+\_\+iter.\+stream.\+block\+\_\+count == 0), lzma\+\_\+index\+\_\+iter.\+block will have undefined values. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{L\+Z\+M\+A\+\_\+\+I\+N\+D\+E\+X\+\_\+\+I\+T\+E\+R\+\_\+\+S\+T\+R\+E\+AM@{L\+Z\+M\+A\+\_\+\+I\+N\+D\+E\+X\+\_\+\+I\+T\+E\+R\+\_\+\+S\+T\+R\+E\+AM}!api/lzma/index.\+h@{api/lzma/index.\+h}}\index{api/lzma/index.\+h@{api/lzma/index.\+h}!L\+Z\+M\+A\+\_\+\+I\+N\+D\+E\+X\+\_\+\+I\+T\+E\+R\+\_\+\+S\+T\+R\+E\+AM@{L\+Z\+M\+A\+\_\+\+I\+N\+D\+E\+X\+\_\+\+I\+T\+E\+R\+\_\+\+S\+T\+R\+E\+AM}}}\mbox{\label{api_2lzma_2index_8h_a712b43192d944bf2f767711343cd9ca8a5b31d985de1c823151acdd7e4a966fc9}} 
L\+Z\+M\+A\+\_\+\+I\+N\+D\+E\+X\+\_\+\+I\+T\+E\+R\+\_\+\+S\+T\+R\+E\+AM&Get the next Stream. Go to the next Stream even if the current Stream has unread Blocks left. If the next Stream has at least one Block, the iterator will point to the first Block. If there are no Blocks, lzma\+\_\+index\+\_\+iter.\+block will have undefined values. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{L\+Z\+M\+A\+\_\+\+I\+N\+D\+E\+X\+\_\+\+I\+T\+E\+R\+\_\+\+B\+L\+O\+CK@{L\+Z\+M\+A\+\_\+\+I\+N\+D\+E\+X\+\_\+\+I\+T\+E\+R\+\_\+\+B\+L\+O\+CK}!api/lzma/index.\+h@{api/lzma/index.\+h}}\index{api/lzma/index.\+h@{api/lzma/index.\+h}!L\+Z\+M\+A\+\_\+\+I\+N\+D\+E\+X\+\_\+\+I\+T\+E\+R\+\_\+\+B\+L\+O\+CK@{L\+Z\+M\+A\+\_\+\+I\+N\+D\+E\+X\+\_\+\+I\+T\+E\+R\+\_\+\+B\+L\+O\+CK}}}\mbox{\label{api_2lzma_2index_8h_a712b43192d944bf2f767711343cd9ca8a2702617d60d6fc15138a749e06ef3414}} 
L\+Z\+M\+A\+\_\+\+I\+N\+D\+E\+X\+\_\+\+I\+T\+E\+R\+\_\+\+B\+L\+O\+CK&Get the next Block. Go to the next Block if the current Stream has at least one Block left. If the current Stream has no Blocks left, the next Stream with at least one Block is located and the iterator will be made to point to the first Block of that Stream. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{L\+Z\+M\+A\+\_\+\+I\+N\+D\+E\+X\+\_\+\+I\+T\+E\+R\+\_\+\+N\+O\+N\+E\+M\+P\+T\+Y\+\_\+\+B\+L\+O\+CK@{L\+Z\+M\+A\+\_\+\+I\+N\+D\+E\+X\+\_\+\+I\+T\+E\+R\+\_\+\+N\+O\+N\+E\+M\+P\+T\+Y\+\_\+\+B\+L\+O\+CK}!api/lzma/index.\+h@{api/lzma/index.\+h}}\index{api/lzma/index.\+h@{api/lzma/index.\+h}!L\+Z\+M\+A\+\_\+\+I\+N\+D\+E\+X\+\_\+\+I\+T\+E\+R\+\_\+\+N\+O\+N\+E\+M\+P\+T\+Y\+\_\+\+B\+L\+O\+CK@{L\+Z\+M\+A\+\_\+\+I\+N\+D\+E\+X\+\_\+\+I\+T\+E\+R\+\_\+\+N\+O\+N\+E\+M\+P\+T\+Y\+\_\+\+B\+L\+O\+CK}}}\mbox{\label{api_2lzma_2index_8h_a712b43192d944bf2f767711343cd9ca8aa49bf4d561d8f2c61d300edbb6c282c7}} 
L\+Z\+M\+A\+\_\+\+I\+N\+D\+E\+X\+\_\+\+I\+T\+E\+R\+\_\+\+N\+O\+N\+E\+M\+P\+T\+Y\+\_\+\+B\+L\+O\+CK&Get the next non-\/empty Block. This is like L\+Z\+M\+A\+\_\+\+I\+N\+D\+E\+X\+\_\+\+I\+T\+E\+R\+\_\+\+B\+L\+O\+CK except that it will skip Blocks whose Uncompressed Size is zero. \\
\hline

\end{DoxyEnumFields}


\subsection{Function Documentation}
\mbox{\label{api_2lzma_2index_8h_a880def3727ecdd7f242807083d228fc5}} 
\index{api/lzma/index.\+h@{api/lzma/index.\+h}!lzma\+\_\+index\+\_\+memusage@{lzma\+\_\+index\+\_\+memusage}}
\index{lzma\+\_\+index\+\_\+memusage@{lzma\+\_\+index\+\_\+memusage}!api/lzma/index.\+h@{api/lzma/index.\+h}}
\subsubsection{lzma\+\_\+index\+\_\+memusage()}
{\footnotesize\ttfamily uint64\+\_\+t lzma\+\_\+index\+\_\+memusage (\begin{DoxyParamCaption}\item[{\textbf{ lzma\+\_\+vli}}]{streams,  }\item[{\textbf{ lzma\+\_\+vli}}]{blocks }\end{DoxyParamCaption})}



Calculate memory usage of lzma\+\_\+index. 

On disk, the size of the Index field depends on both the number of Records stored and how big values the Records store (due to variable-\/length integer encoding). When the Index is kept in lzma\+\_\+index structure, the memory usage depends only on the number of Records/\+Blocks stored in the Index(es), and in case of concatenated lzma\+\_\+indexes, the number of Streams. The size in R\+AM is almost always significantly bigger than in the encoded form on disk.

This function calculates an approximate amount of memory needed hold the given number of Streams and Blocks in lzma\+\_\+index structure. This value may vary between C\+PU architectures and also between liblzma versions if the internal implementation is modified. 

Referenced by lzma\+\_\+index\+\_\+memused().

\mbox{\label{api_2lzma_2index_8h_a4118805ac7be6618aca6d6d7e5e4dde7}} 
\index{api/lzma/index.\+h@{api/lzma/index.\+h}!lzma\+\_\+index\+\_\+memused@{lzma\+\_\+index\+\_\+memused}}
\index{lzma\+\_\+index\+\_\+memused@{lzma\+\_\+index\+\_\+memused}!api/lzma/index.\+h@{api/lzma/index.\+h}}
\subsubsection{lzma\+\_\+index\+\_\+memused()}
{\footnotesize\ttfamily uint64\+\_\+t lzma\+\_\+index\+\_\+memused (\begin{DoxyParamCaption}\item[{const \textbf{ lzma\+\_\+index} $\ast$}]{i }\end{DoxyParamCaption})}



Calculate the memory usage of an existing lzma\+\_\+index. 

This is a shorthand for lzma\+\_\+index\+\_\+memusage(lzma\+\_\+index\+\_\+stream\+\_\+count(i), lzma\+\_\+index\+\_\+block\+\_\+count(i)). 

References lzma\+\_\+index\+\_\+memusage().

\mbox{\label{api_2lzma_2index_8h_a44fa427521c6a20c52afaff08792150e}} 
\index{api/lzma/index.\+h@{api/lzma/index.\+h}!lzma\+\_\+index\+\_\+init@{lzma\+\_\+index\+\_\+init}}
\index{lzma\+\_\+index\+\_\+init@{lzma\+\_\+index\+\_\+init}!api/lzma/index.\+h@{api/lzma/index.\+h}}
\subsubsection{lzma\+\_\+index\+\_\+init()}
{\footnotesize\ttfamily \textbf{ lzma\+\_\+index}$\ast$ lzma\+\_\+index\+\_\+init (\begin{DoxyParamCaption}\item[{const \textbf{ lzma\+\_\+allocator} $\ast$}]{allocator }\end{DoxyParamCaption})}



Allocate and initialize a new lzma\+\_\+index structure. 

\begin{DoxyReturn}{Returns}
On success, a pointer to an empty initialized lzma\+\_\+index is returned. If allocation fails, N\+U\+LL is returned. 
\end{DoxyReturn}
\mbox{\label{api_2lzma_2index_8h_a0c2d0009f07fc315d5ac89e4bcd25abd}} 
\index{api/lzma/index.\+h@{api/lzma/index.\+h}!lzma\+\_\+index\+\_\+end@{lzma\+\_\+index\+\_\+end}}
\index{lzma\+\_\+index\+\_\+end@{lzma\+\_\+index\+\_\+end}!api/lzma/index.\+h@{api/lzma/index.\+h}}
\subsubsection{lzma\+\_\+index\+\_\+end()}
{\footnotesize\ttfamily void lzma\+\_\+index\+\_\+end (\begin{DoxyParamCaption}\item[{\textbf{ lzma\+\_\+index} $\ast$}]{i,  }\item[{const \textbf{ lzma\+\_\+allocator} $\ast$}]{allocator }\end{DoxyParamCaption})}



Deallocate lzma\+\_\+index. 

If i is N\+U\+LL, this does nothing. 

References index\+\_\+stream\+\_\+end(), index\+\_\+tree\+\_\+end(), and lzma\+\_\+free().

\mbox{\label{api_2lzma_2index_8h_ac347747eb933c7c408e6c801b33becc3}} 
\index{api/lzma/index.\+h@{api/lzma/index.\+h}!lzma\+\_\+index\+\_\+append@{lzma\+\_\+index\+\_\+append}}
\index{lzma\+\_\+index\+\_\+append@{lzma\+\_\+index\+\_\+append}!api/lzma/index.\+h@{api/lzma/index.\+h}}
\subsubsection{lzma\+\_\+index\+\_\+append()}
{\footnotesize\ttfamily \textbf{ lzma\+\_\+ret} lzma\+\_\+index\+\_\+append (\begin{DoxyParamCaption}\item[{\textbf{ lzma\+\_\+index} $\ast$}]{i,  }\item[{const \textbf{ lzma\+\_\+allocator} $\ast$}]{allocator,  }\item[{\textbf{ lzma\+\_\+vli}}]{unpadded\+\_\+size,  }\item[{\textbf{ lzma\+\_\+vli}}]{uncompressed\+\_\+size }\end{DoxyParamCaption})}



Add a new Block to lzma\+\_\+index. 


\begin{DoxyParams}{Parameters}
{\em i} & Pointer to a lzma\+\_\+index structure \\
\hline
{\em allocator} & Pointer to \doxyref{lzma\+\_\+allocator}{p.}{structlzma__allocator}, or N\+U\+LL to use malloc() \\
\hline
{\em unpadded\+\_\+size} & Unpadded Size of a Block. This can be calculated with \doxyref{lzma\+\_\+block\+\_\+unpadded\+\_\+size()}{p.}{block_8h_a412d5605280fa29befae1b89e344bf30} after encoding or decoding the Block. \\
\hline
{\em uncompressed\+\_\+size} & Uncompressed Size of a Block. This can be taken directly from \doxyref{lzma\+\_\+block}{p.}{structlzma__block} structure after encoding or decoding the Block.\\
\hline
\end{DoxyParams}
Appending a new Block does not invalidate iterators. For example, if an iterator was pointing to the end of the lzma\+\_\+index, after \doxyref{lzma\+\_\+index\+\_\+append()}{p.}{api_2lzma_2index_8h_ac347747eb933c7c408e6c801b33becc3} it is possible to read the next Block with an existing iterator.

\begin{DoxyReturn}{Returns}
-\/ L\+Z\+M\+A\+\_\+\+OK
\begin{DoxyItemize}
\item L\+Z\+M\+A\+\_\+\+M\+E\+M\+\_\+\+E\+R\+R\+OR
\item L\+Z\+M\+A\+\_\+\+D\+A\+T\+A\+\_\+\+E\+R\+R\+OR\+: Compressed or uncompressed size of the Stream or size of the Index field would grow too big.
\item L\+Z\+M\+A\+\_\+\+P\+R\+O\+G\+\_\+\+E\+R\+R\+OR 
\end{DoxyItemize}
\end{DoxyReturn}
\mbox{\label{api_2lzma_2index_8h_a79a19669237f19f0b11c9f3be80a62b4}} 
\index{api/lzma/index.\+h@{api/lzma/index.\+h}!lzma\+\_\+index\+\_\+stream\+\_\+flags@{lzma\+\_\+index\+\_\+stream\+\_\+flags}}
\index{lzma\+\_\+index\+\_\+stream\+\_\+flags@{lzma\+\_\+index\+\_\+stream\+\_\+flags}!api/lzma/index.\+h@{api/lzma/index.\+h}}
\subsubsection{lzma\+\_\+index\+\_\+stream\+\_\+flags()}
{\footnotesize\ttfamily \textbf{ lzma\+\_\+ret} lzma\+\_\+index\+\_\+stream\+\_\+flags (\begin{DoxyParamCaption}\item[{\textbf{ lzma\+\_\+index} $\ast$}]{i,  }\item[{const \textbf{ lzma\+\_\+stream\+\_\+flags} $\ast$}]{stream\+\_\+flags }\end{DoxyParamCaption})}



Set the Stream Flags. 

Set the Stream Flags of the last (and typically the only) Stream in lzma\+\_\+index. This can be useful when reading information from the lzma\+\_\+index, because to decode Blocks, knowing the integrity check type is needed.

The given Stream Flags are copied into internal preallocated structure in the lzma\+\_\+index, thus the caller doesn\textquotesingle{}t need to keep the $\ast$stream\+\_\+flags available after calling this function.

\begin{DoxyReturn}{Returns}
-\/ L\+Z\+M\+A\+\_\+\+OK
\begin{DoxyItemize}
\item L\+Z\+M\+A\+\_\+\+O\+P\+T\+I\+O\+N\+S\+\_\+\+E\+R\+R\+OR\+: Unsupported stream\+\_\+flags-\/$>$version.
\item L\+Z\+M\+A\+\_\+\+P\+R\+O\+G\+\_\+\+E\+R\+R\+OR 
\end{DoxyItemize}
\end{DoxyReturn}


References L\+Z\+M\+A\+\_\+\+OK, L\+Z\+M\+A\+\_\+\+P\+R\+O\+G\+\_\+\+E\+R\+R\+OR, lzma\+\_\+stream\+\_\+flags\+\_\+compare(), return\+\_\+if\+\_\+error, and index\+\_\+stream\+::stream\+\_\+flags.

\mbox{\label{api_2lzma_2index_8h_af8d6528a04241841bd0a4322b0c57eaa}} 
\index{api/lzma/index.\+h@{api/lzma/index.\+h}!lzma\+\_\+index\+\_\+checks@{lzma\+\_\+index\+\_\+checks}}
\index{lzma\+\_\+index\+\_\+checks@{lzma\+\_\+index\+\_\+checks}!api/lzma/index.\+h@{api/lzma/index.\+h}}
\subsubsection{lzma\+\_\+index\+\_\+checks()}
{\footnotesize\ttfamily uint32\+\_\+t lzma\+\_\+index\+\_\+checks (\begin{DoxyParamCaption}\item[{const \textbf{ lzma\+\_\+index} $\ast$}]{i }\end{DoxyParamCaption})}



Get the types of integrity Checks. 

If \doxyref{lzma\+\_\+index\+\_\+stream\+\_\+flags()}{p.}{api_2lzma_2index_8h_a79a19669237f19f0b11c9f3be80a62b4} is used to set the Stream Flags for every Stream, \doxyref{lzma\+\_\+index\+\_\+checks()}{p.}{api_2lzma_2index_8h_af8d6528a04241841bd0a4322b0c57eaa} can be used to get a bitmask to indicate which Check types have been used. It can be useful e.\+g. if showing the Check types to the user.

The bitmask is 1 $<$$<$ check\+\_\+id, e.\+g. C\+R\+C32 is 1 $<$$<$ 1 and S\+H\+A-\/256 is 1 $<$$<$ 10. \mbox{\label{api_2lzma_2index_8h_a3ed82f96c688f3c953f6509b6f4e2ef3}} 
\index{api/lzma/index.\+h@{api/lzma/index.\+h}!lzma\+\_\+index\+\_\+stream\+\_\+padding@{lzma\+\_\+index\+\_\+stream\+\_\+padding}}
\index{lzma\+\_\+index\+\_\+stream\+\_\+padding@{lzma\+\_\+index\+\_\+stream\+\_\+padding}!api/lzma/index.\+h@{api/lzma/index.\+h}}
\subsubsection{lzma\+\_\+index\+\_\+stream\+\_\+padding()}
{\footnotesize\ttfamily \textbf{ lzma\+\_\+ret} lzma\+\_\+index\+\_\+stream\+\_\+padding (\begin{DoxyParamCaption}\item[{\textbf{ lzma\+\_\+index} $\ast$}]{i,  }\item[{\textbf{ lzma\+\_\+vli}}]{stream\+\_\+padding }\end{DoxyParamCaption})}



Set the amount of Stream Padding. 

Set the amount of Stream Padding of the last (and typically the only) Stream in the lzma\+\_\+index. This is needed when planning to do random-\/access reading within multiple concatenated Streams.

By default, the amount of Stream Padding is assumed to be zero bytes.

\begin{DoxyReturn}{Returns}
-\/ L\+Z\+M\+A\+\_\+\+OK
\begin{DoxyItemize}
\item L\+Z\+M\+A\+\_\+\+D\+A\+T\+A\+\_\+\+E\+R\+R\+OR\+: The file size would grow too big.
\item L\+Z\+M\+A\+\_\+\+P\+R\+O\+G\+\_\+\+E\+R\+R\+OR 
\end{DoxyItemize}
\end{DoxyReturn}
\mbox{\label{api_2lzma_2index_8h_afd159a765b09b0cf79186069a848d07e}} 
\index{api/lzma/index.\+h@{api/lzma/index.\+h}!lzma\+\_\+index\+\_\+stream\+\_\+count@{lzma\+\_\+index\+\_\+stream\+\_\+count}}
\index{lzma\+\_\+index\+\_\+stream\+\_\+count@{lzma\+\_\+index\+\_\+stream\+\_\+count}!api/lzma/index.\+h@{api/lzma/index.\+h}}
\subsubsection{lzma\+\_\+index\+\_\+stream\+\_\+count()}
{\footnotesize\ttfamily \textbf{ lzma\+\_\+vli} lzma\+\_\+index\+\_\+stream\+\_\+count (\begin{DoxyParamCaption}\item[{const \textbf{ lzma\+\_\+index} $\ast$}]{i }\end{DoxyParamCaption})}



Get the number of Streams. 

\mbox{\label{api_2lzma_2index_8h_add1a8c506f67dbc19cae6747107e3bec}} 
\index{api/lzma/index.\+h@{api/lzma/index.\+h}!lzma\+\_\+index\+\_\+block\+\_\+count@{lzma\+\_\+index\+\_\+block\+\_\+count}}
\index{lzma\+\_\+index\+\_\+block\+\_\+count@{lzma\+\_\+index\+\_\+block\+\_\+count}!api/lzma/index.\+h@{api/lzma/index.\+h}}
\subsubsection{lzma\+\_\+index\+\_\+block\+\_\+count()}
{\footnotesize\ttfamily \textbf{ lzma\+\_\+vli} lzma\+\_\+index\+\_\+block\+\_\+count (\begin{DoxyParamCaption}\item[{const \textbf{ lzma\+\_\+index} $\ast$}]{i }\end{DoxyParamCaption})}



Get the number of Blocks. 

This returns the total number of Blocks in lzma\+\_\+index. To get number of Blocks in individual Streams, use \doxyref{lzma\+\_\+index\+\_\+iter}{p.}{structlzma__index__iter}. \mbox{\label{api_2lzma_2index_8h_a669ed1a82b1941217cfbb07e7826afc2}} 
\index{api/lzma/index.\+h@{api/lzma/index.\+h}!lzma\+\_\+index\+\_\+size@{lzma\+\_\+index\+\_\+size}}
\index{lzma\+\_\+index\+\_\+size@{lzma\+\_\+index\+\_\+size}!api/lzma/index.\+h@{api/lzma/index.\+h}}
\subsubsection{lzma\+\_\+index\+\_\+size()}
{\footnotesize\ttfamily \textbf{ lzma\+\_\+vli} lzma\+\_\+index\+\_\+size (\begin{DoxyParamCaption}\item[{const \textbf{ lzma\+\_\+index} $\ast$}]{i }\end{DoxyParamCaption})}



Get the size of the Index field as bytes. 

This is needed to verify the Backward Size field in the Stream Footer. 

Referenced by lzma\+\_\+index\+\_\+buffer\+\_\+encode().

\mbox{\label{api_2lzma_2index_8h_af3630369b43c9ccc906065d759b49663}} 
\index{api/lzma/index.\+h@{api/lzma/index.\+h}!lzma\+\_\+index\+\_\+stream\+\_\+size@{lzma\+\_\+index\+\_\+stream\+\_\+size}}
\index{lzma\+\_\+index\+\_\+stream\+\_\+size@{lzma\+\_\+index\+\_\+stream\+\_\+size}!api/lzma/index.\+h@{api/lzma/index.\+h}}
\subsubsection{lzma\+\_\+index\+\_\+stream\+\_\+size()}
{\footnotesize\ttfamily \textbf{ lzma\+\_\+vli} lzma\+\_\+index\+\_\+stream\+\_\+size (\begin{DoxyParamCaption}\item[{const \textbf{ lzma\+\_\+index} $\ast$}]{i }\end{DoxyParamCaption})}



Get the total size of the Stream. 

If multiple lzma\+\_\+indexes have been combined, this works as if the Blocks were in a single Stream. This is useful if you are going to combine Blocks from multiple Streams into a single new Stream. 

References L\+Z\+M\+A\+\_\+\+S\+T\+R\+E\+A\+M\+\_\+\+H\+E\+A\+D\+E\+R\+\_\+\+S\+I\+ZE.

\mbox{\label{api_2lzma_2index_8h_a7829942b83ee1fa5b6443cc248b81041}} 
\index{api/lzma/index.\+h@{api/lzma/index.\+h}!lzma\+\_\+index\+\_\+total\+\_\+size@{lzma\+\_\+index\+\_\+total\+\_\+size}}
\index{lzma\+\_\+index\+\_\+total\+\_\+size@{lzma\+\_\+index\+\_\+total\+\_\+size}!api/lzma/index.\+h@{api/lzma/index.\+h}}
\subsubsection{lzma\+\_\+index\+\_\+total\+\_\+size()}
{\footnotesize\ttfamily \textbf{ lzma\+\_\+vli} lzma\+\_\+index\+\_\+total\+\_\+size (\begin{DoxyParamCaption}\item[{const \textbf{ lzma\+\_\+index} $\ast$}]{i }\end{DoxyParamCaption})}



Get the total size of the Blocks. 

This doesn\textquotesingle{}t include the Stream Header, Stream Footer, Stream Padding, or Index fields. \mbox{\label{api_2lzma_2index_8h_ac875ed47d35385e5dac461b25c5ea1c9}} 
\index{api/lzma/index.\+h@{api/lzma/index.\+h}!lzma\+\_\+index\+\_\+file\+\_\+size@{lzma\+\_\+index\+\_\+file\+\_\+size}}
\index{lzma\+\_\+index\+\_\+file\+\_\+size@{lzma\+\_\+index\+\_\+file\+\_\+size}!api/lzma/index.\+h@{api/lzma/index.\+h}}
\subsubsection{lzma\+\_\+index\+\_\+file\+\_\+size()}
{\footnotesize\ttfamily \textbf{ lzma\+\_\+vli} lzma\+\_\+index\+\_\+file\+\_\+size (\begin{DoxyParamCaption}\item[{const \textbf{ lzma\+\_\+index} $\ast$}]{i }\end{DoxyParamCaption})}



Get the total size of the file. 

When no lzma\+\_\+indexes have been combined with \doxyref{lzma\+\_\+index\+\_\+cat()}{p.}{api_2lzma_2index_8h_abc4db36b4bd67af01819be9dd045c34a} and there is no Stream Padding, this function is identical to \doxyref{lzma\+\_\+index\+\_\+stream\+\_\+size()}{p.}{api_2lzma_2index_8h_af3630369b43c9ccc906065d759b49663}. If multiple lzma\+\_\+indexes have been combined, this includes also the headers of each separate Stream and the possible Stream Padding fields. \mbox{\label{api_2lzma_2index_8h_a620fe6317f1f9d7af9cc27c748bf07d6}} 
\index{api/lzma/index.\+h@{api/lzma/index.\+h}!lzma\+\_\+index\+\_\+uncompressed\+\_\+size@{lzma\+\_\+index\+\_\+uncompressed\+\_\+size}}
\index{lzma\+\_\+index\+\_\+uncompressed\+\_\+size@{lzma\+\_\+index\+\_\+uncompressed\+\_\+size}!api/lzma/index.\+h@{api/lzma/index.\+h}}
\subsubsection{lzma\+\_\+index\+\_\+uncompressed\+\_\+size()}
{\footnotesize\ttfamily \textbf{ lzma\+\_\+vli} lzma\+\_\+index\+\_\+uncompressed\+\_\+size (\begin{DoxyParamCaption}\item[{const \textbf{ lzma\+\_\+index} $\ast$}]{i }\end{DoxyParamCaption})}



Get the uncompressed size of the file. 

\mbox{\label{api_2lzma_2index_8h_aa78f02f18ed29d289a6ef37b8ea98a21}} 
\index{api/lzma/index.\+h@{api/lzma/index.\+h}!lzma\+\_\+index\+\_\+iter\+\_\+init@{lzma\+\_\+index\+\_\+iter\+\_\+init}}
\index{lzma\+\_\+index\+\_\+iter\+\_\+init@{lzma\+\_\+index\+\_\+iter\+\_\+init}!api/lzma/index.\+h@{api/lzma/index.\+h}}
\subsubsection{lzma\+\_\+index\+\_\+iter\+\_\+init()}
{\footnotesize\ttfamily void lzma\+\_\+index\+\_\+iter\+\_\+init (\begin{DoxyParamCaption}\item[{\textbf{ lzma\+\_\+index\+\_\+iter} $\ast$}]{iter,  }\item[{const \textbf{ lzma\+\_\+index} $\ast$}]{i }\end{DoxyParamCaption})}



Initialize an iterator. 


\begin{DoxyParams}{Parameters}
{\em iter} & Pointer to a \doxyref{lzma\+\_\+index\+\_\+iter}{p.}{structlzma__index__iter} structure \\
\hline
{\em i} & lzma\+\_\+index to which the iterator will be associated\\
\hline
\end{DoxyParams}
This function associates the iterator with the given lzma\+\_\+index, and calls \doxyref{lzma\+\_\+index\+\_\+iter\+\_\+rewind()}{p.}{api_2lzma_2index_8h_ae81438be8deff4894b104e65d8acdd24} on the iterator.

This function doesn\textquotesingle{}t allocate any memory, thus there is no lzma\+\_\+index\+\_\+iter\+\_\+end(). The iterator is valid as long as the associated lzma\+\_\+index is valid, that is, until \doxyref{lzma\+\_\+index\+\_\+end()}{p.}{api_2lzma_2index_8h_a0c2d0009f07fc315d5ac89e4bcd25abd} or using it as source in \doxyref{lzma\+\_\+index\+\_\+cat()}{p.}{api_2lzma_2index_8h_abc4db36b4bd67af01819be9dd045c34a}. Specifically, lzma\+\_\+index doesn\textquotesingle{}t become invalid if new Blocks are added to it with \doxyref{lzma\+\_\+index\+\_\+append()}{p.}{api_2lzma_2index_8h_ac347747eb933c7c408e6c801b33becc3} or if it is used as the destination in \doxyref{lzma\+\_\+index\+\_\+cat()}{p.}{api_2lzma_2index_8h_abc4db36b4bd67af01819be9dd045c34a}.

It is safe to make copies of an initialized \doxyref{lzma\+\_\+index\+\_\+iter}{p.}{structlzma__index__iter}, for example, to easily restart reading at some particular position. \mbox{\label{api_2lzma_2index_8h_ae81438be8deff4894b104e65d8acdd24}} 
\index{api/lzma/index.\+h@{api/lzma/index.\+h}!lzma\+\_\+index\+\_\+iter\+\_\+rewind@{lzma\+\_\+index\+\_\+iter\+\_\+rewind}}
\index{lzma\+\_\+index\+\_\+iter\+\_\+rewind@{lzma\+\_\+index\+\_\+iter\+\_\+rewind}!api/lzma/index.\+h@{api/lzma/index.\+h}}
\subsubsection{lzma\+\_\+index\+\_\+iter\+\_\+rewind()}
{\footnotesize\ttfamily void lzma\+\_\+index\+\_\+iter\+\_\+rewind (\begin{DoxyParamCaption}\item[{\textbf{ lzma\+\_\+index\+\_\+iter} $\ast$}]{iter }\end{DoxyParamCaption})}



Rewind the iterator. 

Rewind the iterator so that next call to \doxyref{lzma\+\_\+index\+\_\+iter\+\_\+next()}{p.}{api_2lzma_2index_8h_af428522e1b3eef137c65c5a01f766e0e} will return the first Block or Stream. \mbox{\label{api_2lzma_2index_8h_af428522e1b3eef137c65c5a01f766e0e}} 
\index{api/lzma/index.\+h@{api/lzma/index.\+h}!lzma\+\_\+index\+\_\+iter\+\_\+next@{lzma\+\_\+index\+\_\+iter\+\_\+next}}
\index{lzma\+\_\+index\+\_\+iter\+\_\+next@{lzma\+\_\+index\+\_\+iter\+\_\+next}!api/lzma/index.\+h@{api/lzma/index.\+h}}
\subsubsection{lzma\+\_\+index\+\_\+iter\+\_\+next()}
{\footnotesize\ttfamily \textbf{ lzma\+\_\+bool} lzma\+\_\+index\+\_\+iter\+\_\+next (\begin{DoxyParamCaption}\item[{\textbf{ lzma\+\_\+index\+\_\+iter} $\ast$}]{iter,  }\item[{\textbf{ lzma\+\_\+index\+\_\+iter\+\_\+mode}}]{mode }\end{DoxyParamCaption})}



Get the next Block or Stream. 


\begin{DoxyParams}{Parameters}
{\em iter} & Iterator initialized with \doxyref{lzma\+\_\+index\+\_\+iter\+\_\+init()}{p.}{api_2lzma_2index_8h_aa78f02f18ed29d289a6ef37b8ea98a21} \\
\hline
{\em mode} & Specify what kind of information the caller wants to get. See lzma\+\_\+index\+\_\+iter\+\_\+mode for details.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
If next Block or Stream matching the mode was found, $\ast$iter is updated and this function returns false. If no Block or Stream matching the mode is found, $\ast$iter is not modified and this function returns true. If mode is set to an unknown value, $\ast$iter is not modified and this function returns true. 
\end{DoxyReturn}


References L\+Z\+M\+A\+\_\+\+I\+N\+D\+E\+X\+\_\+\+I\+T\+E\+R\+\_\+\+N\+O\+N\+E\+M\+P\+T\+Y\+\_\+\+B\+L\+O\+CK.

\mbox{\label{api_2lzma_2index_8h_ac4f56df9d210712e5d7add5502c9eb93}} 
\index{api/lzma/index.\+h@{api/lzma/index.\+h}!lzma\+\_\+index\+\_\+iter\+\_\+locate@{lzma\+\_\+index\+\_\+iter\+\_\+locate}}
\index{lzma\+\_\+index\+\_\+iter\+\_\+locate@{lzma\+\_\+index\+\_\+iter\+\_\+locate}!api/lzma/index.\+h@{api/lzma/index.\+h}}
\subsubsection{lzma\+\_\+index\+\_\+iter\+\_\+locate()}
{\footnotesize\ttfamily \textbf{ lzma\+\_\+bool} lzma\+\_\+index\+\_\+iter\+\_\+locate (\begin{DoxyParamCaption}\item[{\textbf{ lzma\+\_\+index\+\_\+iter} $\ast$}]{iter,  }\item[{\textbf{ lzma\+\_\+vli}}]{target }\end{DoxyParamCaption})}



Locate a Block. 

If it is possible to seek in the .xz file, it is possible to parse the Index field(s) and use \doxyref{lzma\+\_\+index\+\_\+iter\+\_\+locate()}{p.}{api_2lzma_2index_8h_ac4f56df9d210712e5d7add5502c9eb93} to do random-\/access reading with granularity of Block size.


\begin{DoxyParams}{Parameters}
{\em iter} & Iterator that was earlier initialized with \doxyref{lzma\+\_\+index\+\_\+iter\+\_\+init()}{p.}{api_2lzma_2index_8h_aa78f02f18ed29d289a6ef37b8ea98a21}. \\
\hline
{\em target} & Uncompressed target offset which the caller would like to locate from the Stream\\
\hline
\end{DoxyParams}
If the target is smaller than the uncompressed size of the Stream (can be checked with \doxyref{lzma\+\_\+index\+\_\+uncompressed\+\_\+size()}{p.}{api_2lzma_2index_8h_a620fe6317f1f9d7af9cc27c748bf07d6})\+:
\begin{DoxyItemize}
\item Information about the Stream and Block containing the requested uncompressed offset is stored into $\ast$iter.
\item Internal state of the iterator is adjusted so that \doxyref{lzma\+\_\+index\+\_\+iter\+\_\+next()}{p.}{api_2lzma_2index_8h_af428522e1b3eef137c65c5a01f766e0e} can be used to read subsequent Blocks or Streams.
\item This function returns false.
\end{DoxyItemize}

If target is greater than the uncompressed size of the Stream, $\ast$iter is not modified, and this function returns true. \mbox{\label{api_2lzma_2index_8h_abc4db36b4bd67af01819be9dd045c34a}} 
\index{api/lzma/index.\+h@{api/lzma/index.\+h}!lzma\+\_\+index\+\_\+cat@{lzma\+\_\+index\+\_\+cat}}
\index{lzma\+\_\+index\+\_\+cat@{lzma\+\_\+index\+\_\+cat}!api/lzma/index.\+h@{api/lzma/index.\+h}}
\subsubsection{lzma\+\_\+index\+\_\+cat()}
{\footnotesize\ttfamily \textbf{ lzma\+\_\+ret} lzma\+\_\+index\+\_\+cat (\begin{DoxyParamCaption}\item[{\textbf{ lzma\+\_\+index} $\ast$}]{dest,  }\item[{\textbf{ lzma\+\_\+index} $\ast$}]{src,  }\item[{const \textbf{ lzma\+\_\+allocator} $\ast$}]{allocator }\end{DoxyParamCaption})}



Concatenate lzma\+\_\+indexes. 

Concatenating lzma\+\_\+indexes is useful when doing random-\/access reading in multi-\/\+Stream .xz file, or when combining multiple Streams into single Stream.


\begin{DoxyParams}{Parameters}
{\em dest} & lzma\+\_\+index after which src is appended \\
\hline
{\em src} & lzma\+\_\+index to be appended after dest. If this function succeeds, the memory allocated for src is freed or moved to be part of dest, and all iterators pointing to src will become invalid. \\
\hline
{\em allocator} & Custom memory allocator; can be N\+U\+LL to use malloc() and free().\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
-\/ L\+Z\+M\+A\+\_\+\+OK\+: lzma\+\_\+indexes were concatenated successfully. src is now a dangling pointer.
\begin{DoxyItemize}
\item L\+Z\+M\+A\+\_\+\+D\+A\+T\+A\+\_\+\+E\+R\+R\+OR\+: $\ast$dest would grow too big.
\item L\+Z\+M\+A\+\_\+\+M\+E\+M\+\_\+\+E\+R\+R\+OR
\item L\+Z\+M\+A\+\_\+\+P\+R\+O\+G\+\_\+\+E\+R\+R\+OR 
\end{DoxyItemize}
\end{DoxyReturn}
\mbox{\label{api_2lzma_2index_8h_a94211b13b9206eb64fc80482b2906061}} 
\index{api/lzma/index.\+h@{api/lzma/index.\+h}!lzma\+\_\+index\+\_\+dup@{lzma\+\_\+index\+\_\+dup}}
\index{lzma\+\_\+index\+\_\+dup@{lzma\+\_\+index\+\_\+dup}!api/lzma/index.\+h@{api/lzma/index.\+h}}
\subsubsection{lzma\+\_\+index\+\_\+dup()}
{\footnotesize\ttfamily \textbf{ lzma\+\_\+index}$\ast$ lzma\+\_\+index\+\_\+dup (\begin{DoxyParamCaption}\item[{const \textbf{ lzma\+\_\+index} $\ast$}]{i,  }\item[{const \textbf{ lzma\+\_\+allocator} $\ast$}]{allocator }\end{DoxyParamCaption})}



Duplicate lzma\+\_\+index. 

\begin{DoxyReturn}{Returns}
A copy of the lzma\+\_\+index, or N\+U\+LL if memory allocation failed. 
\end{DoxyReturn}
\mbox{\label{api_2lzma_2index_8h_a6800d70f3b2afca085496460cd03211d}} 
\index{api/lzma/index.\+h@{api/lzma/index.\+h}!lzma\+\_\+index\+\_\+encoder@{lzma\+\_\+index\+\_\+encoder}}
\index{lzma\+\_\+index\+\_\+encoder@{lzma\+\_\+index\+\_\+encoder}!api/lzma/index.\+h@{api/lzma/index.\+h}}
\subsubsection{lzma\+\_\+index\+\_\+encoder()}
{\footnotesize\ttfamily \textbf{ lzma\+\_\+ret} lzma\+\_\+index\+\_\+encoder (\begin{DoxyParamCaption}\item[{\textbf{ lzma\+\_\+stream} $\ast$}]{strm,  }\item[{const \textbf{ lzma\+\_\+index} $\ast$}]{i }\end{DoxyParamCaption})}



Initialize .xz Index encoder. 


\begin{DoxyParams}{Parameters}
{\em strm} & Pointer to properly prepared \doxyref{lzma\+\_\+stream}{p.}{structlzma__stream} \\
\hline
{\em i} & Pointer to lzma\+\_\+index which should be encoded.\\
\hline
\end{DoxyParams}
The valid `action\textquotesingle{} values for \doxyref{lzma\+\_\+code()}{p.}{base_8h_a28cc09bc422d5ba1e0187c9f2af5d957} are L\+Z\+M\+A\+\_\+\+R\+UN and L\+Z\+M\+A\+\_\+\+F\+I\+N\+I\+SH. It is enough to use only one of them (you can choose freely).

\begin{DoxyReturn}{Returns}
-\/ L\+Z\+M\+A\+\_\+\+OK\+: Initialization succeeded, continue with \doxyref{lzma\+\_\+code()}{p.}{base_8h_a28cc09bc422d5ba1e0187c9f2af5d957}.
\begin{DoxyItemize}
\item L\+Z\+M\+A\+\_\+\+M\+E\+M\+\_\+\+E\+R\+R\+OR
\item L\+Z\+M\+A\+\_\+\+P\+R\+O\+G\+\_\+\+E\+R\+R\+OR 
\end{DoxyItemize}
\end{DoxyReturn}


References lzma\+\_\+next\+\_\+strm\+\_\+init.

\mbox{\label{api_2lzma_2index_8h_abb56fd1d5914f8900ece7b88b78e5e23}} 
\index{api/lzma/index.\+h@{api/lzma/index.\+h}!lzma\+\_\+index\+\_\+decoder@{lzma\+\_\+index\+\_\+decoder}}
\index{lzma\+\_\+index\+\_\+decoder@{lzma\+\_\+index\+\_\+decoder}!api/lzma/index.\+h@{api/lzma/index.\+h}}
\subsubsection{lzma\+\_\+index\+\_\+decoder()}
{\footnotesize\ttfamily \textbf{ lzma\+\_\+ret} lzma\+\_\+index\+\_\+decoder (\begin{DoxyParamCaption}\item[{\textbf{ lzma\+\_\+stream} $\ast$}]{strm,  }\item[{\textbf{ lzma\+\_\+index} $\ast$$\ast$}]{i,  }\item[{uint64\+\_\+t}]{memlimit }\end{DoxyParamCaption})}



Initialize .xz Index decoder. 


\begin{DoxyParams}{Parameters}
{\em strm} & Pointer to properly prepared \doxyref{lzma\+\_\+stream}{p.}{structlzma__stream} \\
\hline
{\em i} & The decoded Index will be made available via this pointer. Initially this function will set $\ast$i to N\+U\+LL (the old value is ignored). If decoding succeeds (\doxyref{lzma\+\_\+code()}{p.}{base_8h_a28cc09bc422d5ba1e0187c9f2af5d957} returns L\+Z\+M\+A\+\_\+\+S\+T\+R\+E\+A\+M\+\_\+\+E\+ND), $\ast$i will be set to point to a new lzma\+\_\+index, which the application has to later free with \doxyref{lzma\+\_\+index\+\_\+end()}{p.}{api_2lzma_2index_8h_a0c2d0009f07fc315d5ac89e4bcd25abd}. \\
\hline
{\em memlimit} & How much memory the resulting lzma\+\_\+index is allowed to require. liblzma 5.\+2.\+3 and earlier don\textquotesingle{}t allow 0 here and return L\+Z\+M\+A\+\_\+\+P\+R\+O\+G\+\_\+\+E\+R\+R\+OR; later versions treat 0 as if 1 had been specified.\\
\hline
\end{DoxyParams}
Valid `action\textquotesingle{} arguments to \doxyref{lzma\+\_\+code()}{p.}{base_8h_a28cc09bc422d5ba1e0187c9f2af5d957} are L\+Z\+M\+A\+\_\+\+R\+UN and L\+Z\+M\+A\+\_\+\+F\+I\+N\+I\+SH. There is no need to use L\+Z\+M\+A\+\_\+\+F\+I\+N\+I\+SH, but it\textquotesingle{}s allowed because it may simplify certain types of applications.

\begin{DoxyReturn}{Returns}
-\/ L\+Z\+M\+A\+\_\+\+OK\+: Initialization succeeded, continue with \doxyref{lzma\+\_\+code()}{p.}{base_8h_a28cc09bc422d5ba1e0187c9f2af5d957}.
\begin{DoxyItemize}
\item L\+Z\+M\+A\+\_\+\+M\+E\+M\+\_\+\+E\+R\+R\+OR
\item L\+Z\+M\+A\+\_\+\+P\+R\+O\+G\+\_\+\+E\+R\+R\+OR
\end{DoxyItemize}
\end{DoxyReturn}
liblzma 5.\+2.\+3 and older list also L\+Z\+M\+A\+\_\+\+M\+E\+M\+L\+I\+M\+I\+T\+\_\+\+E\+R\+R\+OR here but that error code has never been possible from this initialization function. 

References lzma\+\_\+next\+\_\+strm\+\_\+init.

\mbox{\label{api_2lzma_2index_8h_add1ef06dec8a26d08ae8651cff0fd8d6}} 
\index{api/lzma/index.\+h@{api/lzma/index.\+h}!lzma\+\_\+index\+\_\+buffer\+\_\+encode@{lzma\+\_\+index\+\_\+buffer\+\_\+encode}}
\index{lzma\+\_\+index\+\_\+buffer\+\_\+encode@{lzma\+\_\+index\+\_\+buffer\+\_\+encode}!api/lzma/index.\+h@{api/lzma/index.\+h}}
\subsubsection{lzma\+\_\+index\+\_\+buffer\+\_\+encode()}
{\footnotesize\ttfamily \textbf{ lzma\+\_\+ret} lzma\+\_\+index\+\_\+buffer\+\_\+encode (\begin{DoxyParamCaption}\item[{const \textbf{ lzma\+\_\+index} $\ast$}]{i,  }\item[{uint8\+\_\+t $\ast$}]{out,  }\item[{size\+\_\+t $\ast$}]{out\+\_\+pos,  }\item[{size\+\_\+t}]{out\+\_\+size }\end{DoxyParamCaption})}



Single-\/call .xz Index encoder. 


\begin{DoxyParams}{Parameters}
{\em i} & lzma\+\_\+index to be encoded \\
\hline
{\em out} & Beginning of the output buffer \\
\hline
{\em out\+\_\+pos} & The next byte will be written to out[$\ast$out\+\_\+pos]. $\ast$out\+\_\+pos is updated only if encoding succeeds. \\
\hline
{\em out\+\_\+size} & Size of the out buffer; the first byte into which no data is written to is out[out\+\_\+size].\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
-\/ L\+Z\+M\+A\+\_\+\+OK\+: Encoding was successful.
\begin{DoxyItemize}
\item L\+Z\+M\+A\+\_\+\+B\+U\+F\+\_\+\+E\+R\+R\+OR\+: Output buffer is too small. Use \doxyref{lzma\+\_\+index\+\_\+size()}{p.}{api_2lzma_2index_8h_a669ed1a82b1941217cfbb07e7826afc2} to find out how much output space is needed.
\item L\+Z\+M\+A\+\_\+\+P\+R\+O\+G\+\_\+\+E\+R\+R\+OR
\end{DoxyItemize}
\end{DoxyReturn}
\begin{DoxyNote}{Note}
This function doesn\textquotesingle{}t take allocator argument since all the internal data is allocated on stack. 
\end{DoxyNote}


References L\+Z\+M\+A\+\_\+\+B\+U\+F\+\_\+\+E\+R\+R\+OR, lzma\+\_\+index\+\_\+size(), and L\+Z\+M\+A\+\_\+\+P\+R\+O\+G\+\_\+\+E\+R\+R\+OR.

\mbox{\label{api_2lzma_2index_8h_a028b8b8d59a413f9682eea1269a6ae8b}} 
\index{api/lzma/index.\+h@{api/lzma/index.\+h}!lzma\+\_\+index\+\_\+buffer\+\_\+decode@{lzma\+\_\+index\+\_\+buffer\+\_\+decode}}
\index{lzma\+\_\+index\+\_\+buffer\+\_\+decode@{lzma\+\_\+index\+\_\+buffer\+\_\+decode}!api/lzma/index.\+h@{api/lzma/index.\+h}}
\subsubsection{lzma\+\_\+index\+\_\+buffer\+\_\+decode()}
{\footnotesize\ttfamily \textbf{ lzma\+\_\+ret} lzma\+\_\+index\+\_\+buffer\+\_\+decode (\begin{DoxyParamCaption}\item[{\textbf{ lzma\+\_\+index} $\ast$$\ast$}]{i,  }\item[{uint64\+\_\+t $\ast$}]{memlimit,  }\item[{const \textbf{ lzma\+\_\+allocator} $\ast$}]{allocator,  }\item[{const uint8\+\_\+t $\ast$}]{in,  }\item[{size\+\_\+t $\ast$}]{in\+\_\+pos,  }\item[{size\+\_\+t}]{in\+\_\+size }\end{DoxyParamCaption})}



Single-\/call .xz Index decoder. 


\begin{DoxyParams}{Parameters}
{\em i} & If decoding succeeds, $\ast$i will point to a new lzma\+\_\+index, which the application has to later free with \doxyref{lzma\+\_\+index\+\_\+end()}{p.}{api_2lzma_2index_8h_a0c2d0009f07fc315d5ac89e4bcd25abd}. If an error occurs, $\ast$i will be N\+U\+LL. The old value of $\ast$i is always ignored and thus doesn\textquotesingle{}t need to be initialized by the caller. \\
\hline
{\em memlimit} & Pointer to how much memory the resulting lzma\+\_\+index is allowed to require. The value pointed by this pointer is modified if and only if L\+Z\+M\+A\+\_\+\+M\+E\+M\+L\+I\+M\+I\+T\+\_\+\+E\+R\+R\+OR is returned. \\
\hline
{\em allocator} & Pointer to \doxyref{lzma\+\_\+allocator}{p.}{structlzma__allocator}, or N\+U\+LL to use malloc() \\
\hline
{\em in} & Beginning of the input buffer \\
\hline
{\em in\+\_\+pos} & The next byte will be read from in[$\ast$in\+\_\+pos]. $\ast$in\+\_\+pos is updated only if decoding succeeds. \\
\hline
{\em in\+\_\+size} & Size of the input buffer; the first byte that won\textquotesingle{}t be read is in[in\+\_\+size].\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
-\/ L\+Z\+M\+A\+\_\+\+OK\+: Decoding was successful.
\begin{DoxyItemize}
\item L\+Z\+M\+A\+\_\+\+M\+E\+M\+\_\+\+E\+R\+R\+OR
\item L\+Z\+M\+A\+\_\+\+M\+E\+M\+L\+I\+M\+I\+T\+\_\+\+E\+R\+R\+OR\+: Memory usage limit was reached. The minimum required memlimit value was stored to $\ast$memlimit.
\item L\+Z\+M\+A\+\_\+\+D\+A\+T\+A\+\_\+\+E\+R\+R\+OR
\item L\+Z\+M\+A\+\_\+\+P\+R\+O\+G\+\_\+\+E\+R\+R\+OR 
\end{DoxyItemize}
\end{DoxyReturn}


References L\+Z\+M\+A\+\_\+\+P\+R\+O\+G\+\_\+\+E\+R\+R\+OR, and return\+\_\+if\+\_\+error.

