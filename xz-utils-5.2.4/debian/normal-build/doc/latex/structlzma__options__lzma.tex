\section{lzma\+\_\+options\+\_\+lzma Struct Reference}
\label{structlzma__options__lzma}\index{lzma\+\_\+options\+\_\+lzma@{lzma\+\_\+options\+\_\+lzma}}


Options specific to the L\+Z\+M\+A1 and L\+Z\+M\+A2 filters.  




{\ttfamily \#include $<$lzma12.\+h$>$}

\subsection*{Data Fields}
\begin{DoxyCompactItemize}
\item 
uint32\+\_\+t \textbf{ dict\+\_\+size}
\begin{DoxyCompactList}\small\item\em Dictionary size in bytes. \end{DoxyCompactList}\item 
const uint8\+\_\+t $\ast$ \textbf{ preset\+\_\+dict}
\begin{DoxyCompactList}\small\item\em Pointer to an initial dictionary. \end{DoxyCompactList}\item 
uint32\+\_\+t \textbf{ preset\+\_\+dict\+\_\+size}
\begin{DoxyCompactList}\small\item\em Size of the preset dictionary. \end{DoxyCompactList}\item 
uint32\+\_\+t \textbf{ lc}
\begin{DoxyCompactList}\small\item\em Number of literal context bits. \end{DoxyCompactList}\item 
uint32\+\_\+t \textbf{ lp}
\begin{DoxyCompactList}\small\item\em Number of literal position bits. \end{DoxyCompactList}\item 
uint32\+\_\+t \textbf{ pb}
\begin{DoxyCompactList}\small\item\em Number of position bits. \end{DoxyCompactList}\item 
\textbf{ lzma\+\_\+mode} \textbf{ mode}
\item 
uint32\+\_\+t \textbf{ nice\+\_\+len}
\begin{DoxyCompactList}\small\item\em Nice length of a match. \end{DoxyCompactList}\item 
\textbf{ lzma\+\_\+match\+\_\+finder} \textbf{ mf}
\item 
uint32\+\_\+t \textbf{ depth}
\begin{DoxyCompactList}\small\item\em Maximum search depth in the match finder. \end{DoxyCompactList}\item 
\mbox{\label{structlzma__options__lzma_a4b72e6b2f4d4797f83a98aca012f5dbe}} 
uint32\+\_\+t {\bfseries reserved\+\_\+int1}
\item 
\mbox{\label{structlzma__options__lzma_a6137ed4e246c04096c482ee025d38040}} 
uint32\+\_\+t {\bfseries reserved\+\_\+int2}
\item 
\mbox{\label{structlzma__options__lzma_a74beb2b17e576c874364e0058fa0e603}} 
uint32\+\_\+t {\bfseries reserved\+\_\+int3}
\item 
\mbox{\label{structlzma__options__lzma_ab0a9c3c5d5223a8fe11b4348539187ca}} 
uint32\+\_\+t {\bfseries reserved\+\_\+int4}
\item 
\mbox{\label{structlzma__options__lzma_a6142648309696a5f7c93a7c5bdfc95ee}} 
uint32\+\_\+t {\bfseries reserved\+\_\+int5}
\item 
\mbox{\label{structlzma__options__lzma_a0e98b6455879a7cd0dd14abdfd1eaee0}} 
uint32\+\_\+t {\bfseries reserved\+\_\+int6}
\item 
\mbox{\label{structlzma__options__lzma_a678f10760b968d7c4ae4871449ecbb15}} 
uint32\+\_\+t {\bfseries reserved\+\_\+int7}
\item 
\mbox{\label{structlzma__options__lzma_abba53bf48e31050472d3eeb0c90eb438}} 
uint32\+\_\+t {\bfseries reserved\+\_\+int8}
\item 
\mbox{\label{structlzma__options__lzma_a284d6921883e4b94eb9f11a584b9fc28}} 
\textbf{ lzma\+\_\+reserved\+\_\+enum} {\bfseries reserved\+\_\+enum1}
\item 
\mbox{\label{structlzma__options__lzma_a60402127f2ab147d52f90d71adf9ce1c}} 
\textbf{ lzma\+\_\+reserved\+\_\+enum} {\bfseries reserved\+\_\+enum2}
\item 
\mbox{\label{structlzma__options__lzma_aceab85dcaa62850c0865d211430688c9}} 
\textbf{ lzma\+\_\+reserved\+\_\+enum} {\bfseries reserved\+\_\+enum3}
\item 
\mbox{\label{structlzma__options__lzma_a6744d98bfb2fa6f60220e29520d35ad0}} 
\textbf{ lzma\+\_\+reserved\+\_\+enum} {\bfseries reserved\+\_\+enum4}
\item 
\mbox{\label{structlzma__options__lzma_a68929590ab047b40a3fd53cf99b0ceb8}} 
void $\ast$ {\bfseries reserved\+\_\+ptr1}
\item 
\mbox{\label{structlzma__options__lzma_ac8f6bbe31a15ea3782722f9508a467f0}} 
void $\ast$ {\bfseries reserved\+\_\+ptr2}
\end{DoxyCompactItemize}


\subsection{Detailed Description}
Options specific to the L\+Z\+M\+A1 and L\+Z\+M\+A2 filters. 

Since L\+Z\+M\+A1 and L\+Z\+M\+A2 share most of the code, it\textquotesingle{}s simplest to share the options structure too. For encoding, all but the reserved variables need to be initialized unless specifically mentioned otherwise. \doxyref{lzma\+\_\+lzma\+\_\+preset()}{p.}{lzma12_8h_aa62c28944fe3575653a4c25780400d77} can be used to get a good starting point.

For raw decoding, both L\+Z\+M\+A1 and L\+Z\+M\+A2 need dict\+\_\+size, preset\+\_\+dict, and preset\+\_\+dict\+\_\+size (if preset\+\_\+dict != N\+U\+LL). L\+Z\+M\+A1 needs also lc, lp, and pb. 

\subsection{Field Documentation}
\mbox{\label{structlzma__options__lzma_aeb3f86002405a1191af86def46fca5ad}} 
\index{lzma\+\_\+options\+\_\+lzma@{lzma\+\_\+options\+\_\+lzma}!dict\+\_\+size@{dict\+\_\+size}}
\index{dict\+\_\+size@{dict\+\_\+size}!lzma\+\_\+options\+\_\+lzma@{lzma\+\_\+options\+\_\+lzma}}
\subsubsection{dict\+\_\+size}
{\footnotesize\ttfamily uint32\+\_\+t lzma\+\_\+options\+\_\+lzma\+::dict\+\_\+size}



Dictionary size in bytes. 

Dictionary size indicates how many bytes of the recently processed uncompressed data is kept in memory. One method to reduce size of the uncompressed data is to store distance-\/length pairs, which indicate what data to repeat from the dictionary buffer. Thus, the bigger the dictionary, the better the compression ratio usually is.

Maximum size of the dictionary depends on multiple things\+:
\begin{DoxyItemize}
\item Memory usage limit
\item Available address space (not a problem on 64-\/bit systems)
\item Selected match finder (encoder only)
\end{DoxyItemize}

Currently the maximum dictionary size for encoding is 1.\+5 GiB (i.\+e. (U\+I\+N\+T32\+\_\+\+C(1) $<$$<$ 30) + (U\+I\+N\+T32\+\_\+\+C(1) $<$$<$ 29)) even on 64-\/bit systems for certain match finder implementation reasons. In the future, there may be match finders that support bigger dictionaries.

Decoder already supports dictionaries up to 4 GiB -\/ 1 B (i.\+e. U\+I\+N\+T32\+\_\+\+M\+AX), so increasing the maximum dictionary size of the encoder won\textquotesingle{}t cause problems for old decoders.

Because extremely small dictionaries sizes would have unneeded overhead in the decoder, the minimum dictionary size is 4096 bytes.

\begin{DoxyNote}{Note}
When decoding, too big dictionary does no other harm than wasting memory. 
\end{DoxyNote}


Referenced by message\+\_\+filters\+\_\+to\+\_\+str().

\mbox{\label{structlzma__options__lzma_a16a58c1ee3ec18c820d5cb03dde3739a}} 
\index{lzma\+\_\+options\+\_\+lzma@{lzma\+\_\+options\+\_\+lzma}!preset\+\_\+dict@{preset\+\_\+dict}}
\index{preset\+\_\+dict@{preset\+\_\+dict}!lzma\+\_\+options\+\_\+lzma@{lzma\+\_\+options\+\_\+lzma}}
\subsubsection{preset\+\_\+dict}
{\footnotesize\ttfamily const uint8\+\_\+t$\ast$ lzma\+\_\+options\+\_\+lzma\+::preset\+\_\+dict}



Pointer to an initial dictionary. 

It is possible to initialize the L\+Z77 history window using a preset dictionary. It is useful when compressing many similar, relatively small chunks of data independently from each other. The preset dictionary should contain typical strings that occur in the files being compressed. The most probable strings should be near the end of the preset dictionary.

This feature should be used only in special situations. For now, it works correctly only with raw encoding and decoding. Currently none of the container formats supported by liblzma allow preset dictionary when decoding, thus if you create a .xz or .lzma file with preset dictionary, it cannot be decoded with the regular decoder functions. In the future, the .xz format will likely get support for preset dictionary though. \mbox{\label{structlzma__options__lzma_a655ad4cce9e4dac9cf2a5c8daaa629e0}} 
\index{lzma\+\_\+options\+\_\+lzma@{lzma\+\_\+options\+\_\+lzma}!preset\+\_\+dict\+\_\+size@{preset\+\_\+dict\+\_\+size}}
\index{preset\+\_\+dict\+\_\+size@{preset\+\_\+dict\+\_\+size}!lzma\+\_\+options\+\_\+lzma@{lzma\+\_\+options\+\_\+lzma}}
\subsubsection{preset\+\_\+dict\+\_\+size}
{\footnotesize\ttfamily uint32\+\_\+t lzma\+\_\+options\+\_\+lzma\+::preset\+\_\+dict\+\_\+size}



Size of the preset dictionary. 

Specifies the size of the preset dictionary. If the size is bigger than dict\+\_\+size, only the last dict\+\_\+size bytes are processed.

This variable is read only when preset\+\_\+dict is not N\+U\+LL. If preset\+\_\+dict is not N\+U\+LL but preset\+\_\+dict\+\_\+size is zero, no preset dictionary is used (identical to only setting preset\+\_\+dict to N\+U\+LL). \mbox{\label{structlzma__options__lzma_a95f6188e5b5f05c50ec463a315df3585}} 
\index{lzma\+\_\+options\+\_\+lzma@{lzma\+\_\+options\+\_\+lzma}!lc@{lc}}
\index{lc@{lc}!lzma\+\_\+options\+\_\+lzma@{lzma\+\_\+options\+\_\+lzma}}
\subsubsection{lc}
{\footnotesize\ttfamily uint32\+\_\+t lzma\+\_\+options\+\_\+lzma\+::lc}



Number of literal context bits. 

How many of the highest bits of the previous uncompressed eight-\/bit byte (also known as `literal\textquotesingle{}) are taken into account when predicting the bits of the next literal.

E.\+g. in typical English text, an upper-\/case letter is often followed by a lower-\/case letter, and a lower-\/case letter is usually followed by another lower-\/case letter. In the U\+S-\/\+A\+S\+C\+II character set, the highest three bits are 010 for upper-\/case letters and 011 for lower-\/case letters. When lc is at least 3, the literal coding can take advantage of this property in the uncompressed data.

There is a limit that applies to literal context bits and literal position bits together\+: lc + lp $<$= 4. Without this limit the decoding could become very slow, which could have security related results in some cases like email servers doing virus scanning. This limit also simplifies the internal implementation in liblzma.

There may be L\+Z\+M\+A1 streams that have lc + lp $>$ 4 (maximum possible lc would be 8). It is not possible to decode such streams with liblzma. 

Referenced by is\+\_\+lclppb\+\_\+valid(), lzma\+\_\+lzma\+\_\+lclppb\+\_\+decode(), and lzma\+\_\+lzma\+\_\+lclppb\+\_\+encode().

\mbox{\label{structlzma__options__lzma_a0fe9c54e808fce3090b6994d95fe41fe}} 
\index{lzma\+\_\+options\+\_\+lzma@{lzma\+\_\+options\+\_\+lzma}!lp@{lp}}
\index{lp@{lp}!lzma\+\_\+options\+\_\+lzma@{lzma\+\_\+options\+\_\+lzma}}
\subsubsection{lp}
{\footnotesize\ttfamily uint32\+\_\+t lzma\+\_\+options\+\_\+lzma\+::lp}



Number of literal position bits. 

lp affects what kind of alignment in the uncompressed data is assumed when encoding literals. A literal is a single 8-\/bit byte. See pb below for more information about alignment. 

Referenced by lzma\+\_\+lzma\+\_\+lclppb\+\_\+decode(), and lzma\+\_\+lzma\+\_\+lclppb\+\_\+encode().

\mbox{\label{structlzma__options__lzma_acae107b3d3e9d0d4fe16103be22f4408}} 
\index{lzma\+\_\+options\+\_\+lzma@{lzma\+\_\+options\+\_\+lzma}!pb@{pb}}
\index{pb@{pb}!lzma\+\_\+options\+\_\+lzma@{lzma\+\_\+options\+\_\+lzma}}
\subsubsection{pb}
{\footnotesize\ttfamily uint32\+\_\+t lzma\+\_\+options\+\_\+lzma\+::pb}



Number of position bits. 

pb affects what kind of alignment in the uncompressed data is assumed in general. The default means four-\/byte alignment (2$^\wedge$ pb =2$^\wedge$2=4), which is often a good choice when there\textquotesingle{}s no better guess.

When the aligment is known, setting pb accordingly may reduce the file size a little. E.\+g. with text files having one-\/byte alignment (U\+S-\/\+A\+S\+C\+II, I\+S\+O-\/8859-\/$\ast$, U\+T\+F-\/8), setting pb=0 can improve compression slightly. For U\+T\+F-\/16 text, pb=1 is a good choice. If the alignment is an odd number like 3 bytes, pb=0 might be the best choice.

Even though the assumed alignment can be adjusted with pb and lp, L\+Z\+M\+A1 and L\+Z\+M\+A2 still slightly favor 16-\/byte alignment. It might be worth taking into account when designing file formats that are likely to be often compressed with L\+Z\+M\+A1 or L\+Z\+M\+A2. 

Referenced by lzma\+\_\+lzma\+\_\+lclppb\+\_\+decode(), and lzma\+\_\+lzma\+\_\+lclppb\+\_\+encode().

\mbox{\label{structlzma__options__lzma_a1d711df9bda046fd3899abf21fa250d5}} 
\index{lzma\+\_\+options\+\_\+lzma@{lzma\+\_\+options\+\_\+lzma}!mode@{mode}}
\index{mode@{mode}!lzma\+\_\+options\+\_\+lzma@{lzma\+\_\+options\+\_\+lzma}}
\subsubsection{mode}
{\footnotesize\ttfamily \textbf{ lzma\+\_\+mode} lzma\+\_\+options\+\_\+lzma\+::mode}

Compression mode 

Referenced by message\+\_\+filters\+\_\+to\+\_\+str().

\mbox{\label{structlzma__options__lzma_a0352ea7f8b6a43b745a44f6cb4e2d263}} 
\index{lzma\+\_\+options\+\_\+lzma@{lzma\+\_\+options\+\_\+lzma}!nice\+\_\+len@{nice\+\_\+len}}
\index{nice\+\_\+len@{nice\+\_\+len}!lzma\+\_\+options\+\_\+lzma@{lzma\+\_\+options\+\_\+lzma}}
\subsubsection{nice\+\_\+len}
{\footnotesize\ttfamily uint32\+\_\+t lzma\+\_\+options\+\_\+lzma\+::nice\+\_\+len}



Nice length of a match. 

This determines how many bytes the encoder compares from the match candidates when looking for the best match. Once a match of at least nice\+\_\+len bytes long is found, the encoder stops looking for better candidates and encodes the match. (Naturally, if the found match is actually longer than nice\+\_\+len, the actual length is encoded; it\textquotesingle{}s not truncated to nice\+\_\+len.)

Bigger values usually increase the compression ratio and compression time. For most files, 32 to 128 is a good value, which gives very good compression ratio at good speed.

The exact minimum value depends on the match finder. The maximum is 273, which is the maximum length of a match that L\+Z\+M\+A1 and L\+Z\+M\+A2 can encode. \mbox{\label{structlzma__options__lzma_aa99612cd52259093007f33513882dcd0}} 
\index{lzma\+\_\+options\+\_\+lzma@{lzma\+\_\+options\+\_\+lzma}!mf@{mf}}
\index{mf@{mf}!lzma\+\_\+options\+\_\+lzma@{lzma\+\_\+options\+\_\+lzma}}
\subsubsection{mf}
{\footnotesize\ttfamily \textbf{ lzma\+\_\+match\+\_\+finder} lzma\+\_\+options\+\_\+lzma\+::mf}

Match finder ID 

Referenced by message\+\_\+filters\+\_\+to\+\_\+str().

\mbox{\label{structlzma__options__lzma_a4226f686e8c9f6288595fe23d0e15713}} 
\index{lzma\+\_\+options\+\_\+lzma@{lzma\+\_\+options\+\_\+lzma}!depth@{depth}}
\index{depth@{depth}!lzma\+\_\+options\+\_\+lzma@{lzma\+\_\+options\+\_\+lzma}}
\subsubsection{depth}
{\footnotesize\ttfamily uint32\+\_\+t lzma\+\_\+options\+\_\+lzma\+::depth}



Maximum search depth in the match finder. 

For every input byte, match finder searches through the hash chain or binary tree in a loop, each iteration going one step deeper in the chain or tree. The searching stops if
\begin{DoxyItemize}
\item a match of at least nice\+\_\+len bytes long is found;
\item all match candidates from the hash chain or binary tree have been checked; or
\item maximum search depth is reached.
\end{DoxyItemize}

Maximum search depth is needed to prevent the match finder from wasting too much time in case there are lots of short match candidates. On the other hand, stopping the search before all candidates have been checked can reduce compression ratio.

Setting depth to zero tells liblzma to use an automatic default value, that depends on the selected match finder and nice\+\_\+len. The default is in the range [4, 200] or so (it may vary between liblzma versions).

Using a bigger depth value than the default can increase compression ratio in some cases. There is no strict maximum value, but high values (thousands or millions) should be used with care\+: the encoder could remain fast enough with typical input, but malicious input could cause the match finder to slow down dramatically, possibly creating a denial of service attack. 

The documentation for this struct was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
liblzma/api/lzma/\textbf{ lzma12.\+h}\end{DoxyCompactItemize}
