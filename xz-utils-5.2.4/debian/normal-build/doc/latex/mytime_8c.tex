\section{xz/mytime.c File Reference}
\label{mytime_8c}\index{xz/mytime.\+c@{xz/mytime.\+c}}


Time handling functions.  


{\ttfamily \#include \char`\"{}private.\+h\char`\"{}}\newline
{\ttfamily \#include $<$sys/time.\+h$>$}\newline
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
static uint64\+\_\+t \textbf{ mytime\+\_\+now} (void)
\begin{DoxyCompactList}\small\item\em Get the current time as milliseconds. \end{DoxyCompactList}\item 
void \textbf{ mytime\+\_\+set\+\_\+start\+\_\+time} (void)
\begin{DoxyCompactList}\small\item\em Store the time when (de)compression was started. \end{DoxyCompactList}\item 
uint64\+\_\+t \textbf{ mytime\+\_\+get\+\_\+elapsed} (void)
\begin{DoxyCompactList}\small\item\em Get the number of milliseconds since the operation started. \end{DoxyCompactList}\item 
void \textbf{ mytime\+\_\+set\+\_\+flush\+\_\+time} (void)
\begin{DoxyCompactList}\small\item\em Store the time of when compressor was flushed. \end{DoxyCompactList}\item 
int \textbf{ mytime\+\_\+get\+\_\+flush\+\_\+timeout} (void)
\begin{DoxyCompactList}\small\item\em Get the number of milliseconds until the next flush. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Variables}
\begin{DoxyCompactItemize}
\item 
uint64\+\_\+t \textbf{ opt\+\_\+flush\+\_\+timeout} = 0
\begin{DoxyCompactList}\small\item\em Number of milliseconds to between L\+Z\+M\+A\+\_\+\+S\+Y\+N\+C\+\_\+\+F\+L\+U\+S\+Hes. \end{DoxyCompactList}\item 
bool \textbf{ flush\+\_\+needed}
\begin{DoxyCompactList}\small\item\em True when flushing is needed due to expired timeout. \end{DoxyCompactList}\item 
\mbox{\label{mytime_8c_a5b11efea935978e9f1913e964a5e5396}} 
static uint64\+\_\+t {\bfseries start\+\_\+time}
\item 
\mbox{\label{mytime_8c_af6b93fa2981864c6e2f0358edfa88897}} 
static uint64\+\_\+t {\bfseries next\+\_\+flush}
\end{DoxyCompactItemize}


\subsection{Detailed Description}
Time handling functions. 



\subsection{Function Documentation}
\mbox{\label{mytime_8c_aa88d8754572c09d04f39023b7532a669}} 
\index{mytime.\+c@{mytime.\+c}!mytime\+\_\+now@{mytime\+\_\+now}}
\index{mytime\+\_\+now@{mytime\+\_\+now}!mytime.\+c@{mytime.\+c}}
\subsubsection{mytime\+\_\+now()}
{\footnotesize\ttfamily static uint64\+\_\+t mytime\+\_\+now (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Get the current time as milliseconds. 

It\textquotesingle{}s relative to some point but not necessarily to the U\+N\+IX Epoch. 

Referenced by mytime\+\_\+get\+\_\+elapsed().

\mbox{\label{mytime_8c_abc987b617c3d37bb64f26e2e6a1047f8}} 
\index{mytime.\+c@{mytime.\+c}!mytime\+\_\+set\+\_\+start\+\_\+time@{mytime\+\_\+set\+\_\+start\+\_\+time}}
\index{mytime\+\_\+set\+\_\+start\+\_\+time@{mytime\+\_\+set\+\_\+start\+\_\+time}!mytime.\+c@{mytime.\+c}}
\subsubsection{mytime\+\_\+set\+\_\+start\+\_\+time()}
{\footnotesize\ttfamily void mytime\+\_\+set\+\_\+start\+\_\+time (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Store the time when (de)compression was started. 

The start time is also stored as the time of the first flush. \mbox{\label{mytime_8c_a1cbb67212ba8955425ec3ae30f854964}} 
\index{mytime.\+c@{mytime.\+c}!mytime\+\_\+get\+\_\+elapsed@{mytime\+\_\+get\+\_\+elapsed}}
\index{mytime\+\_\+get\+\_\+elapsed@{mytime\+\_\+get\+\_\+elapsed}!mytime.\+c@{mytime.\+c}}
\subsubsection{mytime\+\_\+get\+\_\+elapsed()}
{\footnotesize\ttfamily uint64\+\_\+t mytime\+\_\+get\+\_\+elapsed (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Get the number of milliseconds since the operation started. 



References mytime\+\_\+now().



Referenced by message\+\_\+progress\+\_\+update().

\mbox{\label{mytime_8c_ade93cf3cf43b05f8cb67474ad7d7589f}} 
\index{mytime.\+c@{mytime.\+c}!mytime\+\_\+set\+\_\+flush\+\_\+time@{mytime\+\_\+set\+\_\+flush\+\_\+time}}
\index{mytime\+\_\+set\+\_\+flush\+\_\+time@{mytime\+\_\+set\+\_\+flush\+\_\+time}!mytime.\+c@{mytime.\+c}}
\subsubsection{mytime\+\_\+set\+\_\+flush\+\_\+time()}
{\footnotesize\ttfamily void mytime\+\_\+set\+\_\+flush\+\_\+time (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Store the time of when compressor was flushed. 

\mbox{\label{mytime_8c_ab0193efe1ad07b8eef17bbf712fbe788}} 
\index{mytime.\+c@{mytime.\+c}!mytime\+\_\+get\+\_\+flush\+\_\+timeout@{mytime\+\_\+get\+\_\+flush\+\_\+timeout}}
\index{mytime\+\_\+get\+\_\+flush\+\_\+timeout@{mytime\+\_\+get\+\_\+flush\+\_\+timeout}!mytime.\+c@{mytime.\+c}}
\subsubsection{mytime\+\_\+get\+\_\+flush\+\_\+timeout()}
{\footnotesize\ttfamily int mytime\+\_\+get\+\_\+flush\+\_\+timeout (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Get the number of milliseconds until the next flush. 

This returns -\/1 if no timed flushing is used.

The return value is inteded for use with poll(). 

References opt\+\_\+flush\+\_\+timeout, and opt\+\_\+mode.



\subsection{Variable Documentation}
\mbox{\label{mytime_8c_a8c313eb268d319b6a5e538628049333a}} 
\index{mytime.\+c@{mytime.\+c}!opt\+\_\+flush\+\_\+timeout@{opt\+\_\+flush\+\_\+timeout}}
\index{opt\+\_\+flush\+\_\+timeout@{opt\+\_\+flush\+\_\+timeout}!mytime.\+c@{mytime.\+c}}
\subsubsection{opt\+\_\+flush\+\_\+timeout}
{\footnotesize\ttfamily uint64\+\_\+t opt\+\_\+flush\+\_\+timeout = 0}



Number of milliseconds to between L\+Z\+M\+A\+\_\+\+S\+Y\+N\+C\+\_\+\+F\+L\+U\+S\+Hes. 

If 0, timed flushing is disabled. Otherwise if no more input is available and not at the end of the file and at least opt\+\_\+flush\+\_\+timeout milliseconds has elapsed since the start of compression or the previous flushing (L\+Z\+M\+A\+\_\+\+S\+Y\+N\+C\+\_\+\+F\+L\+U\+SH or L\+Z\+M\+A\+\_\+\+F\+U\+L\+L\+\_\+\+F\+L\+U\+SH), set L\+Z\+M\+A\+\_\+\+S\+Y\+N\+C\+\_\+\+F\+L\+U\+SH to flush the pending data. 

Referenced by mytime\+\_\+get\+\_\+flush\+\_\+timeout().

\mbox{\label{mytime_8c_ab6d388eefb45931239a4c197f6f70899}} 
\index{mytime.\+c@{mytime.\+c}!flush\+\_\+needed@{flush\+\_\+needed}}
\index{flush\+\_\+needed@{flush\+\_\+needed}!mytime.\+c@{mytime.\+c}}
\subsubsection{flush\+\_\+needed}
{\footnotesize\ttfamily bool flush\+\_\+needed}



True when flushing is needed due to expired timeout. 

