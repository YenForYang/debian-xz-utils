\section{liblzma/common/index\+\_\+hash.c File Reference}
\label{index__hash_8c}\index{liblzma/common/index\+\_\+hash.\+c@{liblzma/common/index\+\_\+hash.\+c}}


Validates Index by using a hash function.  


{\ttfamily \#include \char`\"{}common.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}index.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}check.\+h\char`\"{}}\newline
\subsection*{Data Structures}
\begin{DoxyCompactItemize}
\item 
struct \textbf{ lzma\+\_\+index\+\_\+hash\+\_\+info}
\item 
struct \textbf{ lzma\+\_\+index\+\_\+hash\+\_\+s}
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\textbf{ lzma\+\_\+index\+\_\+hash} $\ast$ \textbf{ lzma\+\_\+index\+\_\+hash\+\_\+init} (\textbf{ lzma\+\_\+index\+\_\+hash} $\ast$index\+\_\+hash, const \textbf{ lzma\+\_\+allocator} $\ast$allocator)
\begin{DoxyCompactList}\small\item\em Allocate and initialize a new lzma\+\_\+index\+\_\+hash structure. \end{DoxyCompactList}\item 
void \textbf{ lzma\+\_\+index\+\_\+hash\+\_\+end} (\textbf{ lzma\+\_\+index\+\_\+hash} $\ast$index\+\_\+hash, const \textbf{ lzma\+\_\+allocator} $\ast$allocator)
\begin{DoxyCompactList}\small\item\em Deallocate lzma\+\_\+index\+\_\+hash structure. \end{DoxyCompactList}\item 
\textbf{ lzma\+\_\+vli} \textbf{ lzma\+\_\+index\+\_\+hash\+\_\+size} (const \textbf{ lzma\+\_\+index\+\_\+hash} $\ast$index\+\_\+hash)
\begin{DoxyCompactList}\small\item\em Get the size of the Index field as bytes. \end{DoxyCompactList}\item 
static \textbf{ lzma\+\_\+ret} \textbf{ hash\+\_\+append} (\textbf{ lzma\+\_\+index\+\_\+hash\+\_\+info} $\ast$info, \textbf{ lzma\+\_\+vli} unpadded\+\_\+size, \textbf{ lzma\+\_\+vli} uncompressed\+\_\+size)
\begin{DoxyCompactList}\small\item\em Updates the sizes and the hash without any validation. \end{DoxyCompactList}\item 
\textbf{ lzma\+\_\+ret} \textbf{ lzma\+\_\+index\+\_\+hash\+\_\+append} (\textbf{ lzma\+\_\+index\+\_\+hash} $\ast$index\+\_\+hash, \textbf{ lzma\+\_\+vli} unpadded\+\_\+size, \textbf{ lzma\+\_\+vli} uncompressed\+\_\+size)
\begin{DoxyCompactList}\small\item\em Add a new Record to an Index hash. \end{DoxyCompactList}\item 
\textbf{ lzma\+\_\+ret} \textbf{ lzma\+\_\+index\+\_\+hash\+\_\+decode} (\textbf{ lzma\+\_\+index\+\_\+hash} $\ast$index\+\_\+hash, const uint8\+\_\+t $\ast$in, size\+\_\+t $\ast$in\+\_\+pos, size\+\_\+t in\+\_\+size)
\begin{DoxyCompactList}\small\item\em Decode and validate the Index field. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
Validates Index by using a hash function. 



\subsection{Function Documentation}
\mbox{\label{index__hash_8c_a47fdde8e5cbb4a19fa0ab947e4cc650c}} 
\index{index\+\_\+hash.\+c@{index\+\_\+hash.\+c}!lzma\+\_\+index\+\_\+hash\+\_\+init@{lzma\+\_\+index\+\_\+hash\+\_\+init}}
\index{lzma\+\_\+index\+\_\+hash\+\_\+init@{lzma\+\_\+index\+\_\+hash\+\_\+init}!index\+\_\+hash.\+c@{index\+\_\+hash.\+c}}
\subsubsection{lzma\+\_\+index\+\_\+hash\+\_\+init()}
{\footnotesize\ttfamily \textbf{ lzma\+\_\+index\+\_\+hash}$\ast$ lzma\+\_\+index\+\_\+hash\+\_\+init (\begin{DoxyParamCaption}\item[{\textbf{ lzma\+\_\+index\+\_\+hash} $\ast$}]{index\+\_\+hash,  }\item[{const \textbf{ lzma\+\_\+allocator} $\ast$}]{allocator }\end{DoxyParamCaption})}



Allocate and initialize a new lzma\+\_\+index\+\_\+hash structure. 

If index\+\_\+hash is N\+U\+LL, a new lzma\+\_\+index\+\_\+hash structure is allocated, initialized, and a pointer to it returned. If allocation fails, N\+U\+LL is returned.

If index\+\_\+hash is non-\/\+N\+U\+LL, it is reinitialized and the same pointer returned. In this case, return value cannot be N\+U\+LL or a different pointer than the index\+\_\+hash that was given as an argument. \mbox{\label{index__hash_8c_ab27cc84607b9a8e020d3c2713cc8c7a9}} 
\index{index\+\_\+hash.\+c@{index\+\_\+hash.\+c}!lzma\+\_\+index\+\_\+hash\+\_\+end@{lzma\+\_\+index\+\_\+hash\+\_\+end}}
\index{lzma\+\_\+index\+\_\+hash\+\_\+end@{lzma\+\_\+index\+\_\+hash\+\_\+end}!index\+\_\+hash.\+c@{index\+\_\+hash.\+c}}
\subsubsection{lzma\+\_\+index\+\_\+hash\+\_\+end()}
{\footnotesize\ttfamily void lzma\+\_\+index\+\_\+hash\+\_\+end (\begin{DoxyParamCaption}\item[{\textbf{ lzma\+\_\+index\+\_\+hash} $\ast$}]{index\+\_\+hash,  }\item[{const \textbf{ lzma\+\_\+allocator} $\ast$}]{allocator }\end{DoxyParamCaption})}



Deallocate lzma\+\_\+index\+\_\+hash structure. 

\mbox{\label{index__hash_8c_a32be74e93c9c24752c0cddc53a8d3148}} 
\index{index\+\_\+hash.\+c@{index\+\_\+hash.\+c}!lzma\+\_\+index\+\_\+hash\+\_\+size@{lzma\+\_\+index\+\_\+hash\+\_\+size}}
\index{lzma\+\_\+index\+\_\+hash\+\_\+size@{lzma\+\_\+index\+\_\+hash\+\_\+size}!index\+\_\+hash.\+c@{index\+\_\+hash.\+c}}
\subsubsection{lzma\+\_\+index\+\_\+hash\+\_\+size()}
{\footnotesize\ttfamily \textbf{ lzma\+\_\+vli} lzma\+\_\+index\+\_\+hash\+\_\+size (\begin{DoxyParamCaption}\item[{const \textbf{ lzma\+\_\+index\+\_\+hash} $\ast$}]{index\+\_\+hash }\end{DoxyParamCaption})}



Get the size of the Index field as bytes. 

This is needed to verify the Backward Size field in the Stream Footer. \mbox{\label{index__hash_8c_a1670b0c9e4dd89cecdae1327c661efba}} 
\index{index\+\_\+hash.\+c@{index\+\_\+hash.\+c}!hash\+\_\+append@{hash\+\_\+append}}
\index{hash\+\_\+append@{hash\+\_\+append}!index\+\_\+hash.\+c@{index\+\_\+hash.\+c}}
\subsubsection{hash\+\_\+append()}
{\footnotesize\ttfamily static \textbf{ lzma\+\_\+ret} hash\+\_\+append (\begin{DoxyParamCaption}\item[{\textbf{ lzma\+\_\+index\+\_\+hash\+\_\+info} $\ast$}]{info,  }\item[{\textbf{ lzma\+\_\+vli}}]{unpadded\+\_\+size,  }\item[{\textbf{ lzma\+\_\+vli}}]{uncompressed\+\_\+size }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Updates the sizes and the hash without any validation. 



References lzma\+\_\+index\+\_\+hash\+\_\+info\+::blocks\+\_\+size, lzma\+\_\+index\+\_\+hash\+\_\+info\+::check, lzma\+\_\+index\+\_\+hash\+\_\+info\+::count, lzma\+\_\+index\+\_\+hash\+\_\+info\+::index\+\_\+list\+\_\+size, lzma\+\_\+check\+\_\+update(), L\+Z\+M\+A\+\_\+\+OK, lzma\+\_\+vli\+\_\+size(), lzma\+\_\+index\+\_\+hash\+\_\+info\+::uncompressed\+\_\+size, lzma\+\_\+index\+\_\+hash\+\_\+s\+::uncompressed\+\_\+size, and lzma\+\_\+index\+\_\+hash\+\_\+s\+::unpadded\+\_\+size.



Referenced by lzma\+\_\+index\+\_\+hash\+\_\+append(), and lzma\+\_\+index\+\_\+hash\+\_\+decode().

\mbox{\label{index__hash_8c_a29b6194063af60c27dab0309b793598a}} 
\index{index\+\_\+hash.\+c@{index\+\_\+hash.\+c}!lzma\+\_\+index\+\_\+hash\+\_\+append@{lzma\+\_\+index\+\_\+hash\+\_\+append}}
\index{lzma\+\_\+index\+\_\+hash\+\_\+append@{lzma\+\_\+index\+\_\+hash\+\_\+append}!index\+\_\+hash.\+c@{index\+\_\+hash.\+c}}
\subsubsection{lzma\+\_\+index\+\_\+hash\+\_\+append()}
{\footnotesize\ttfamily \textbf{ lzma\+\_\+ret} lzma\+\_\+index\+\_\+hash\+\_\+append (\begin{DoxyParamCaption}\item[{\textbf{ lzma\+\_\+index\+\_\+hash} $\ast$}]{index\+\_\+hash,  }\item[{\textbf{ lzma\+\_\+vli}}]{unpadded\+\_\+size,  }\item[{\textbf{ lzma\+\_\+vli}}]{uncompressed\+\_\+size }\end{DoxyParamCaption})}



Add a new Record to an Index hash. 


\begin{DoxyParams}{Parameters}
{\em index} & Pointer to a lzma\+\_\+index\+\_\+hash structure \\
\hline
{\em unpadded\+\_\+size} & Unpadded Size of a Block \\
\hline
{\em uncompressed\+\_\+size} & Uncompressed Size of a Block\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
-\/ L\+Z\+M\+A\+\_\+\+OK
\begin{DoxyItemize}
\item L\+Z\+M\+A\+\_\+\+D\+A\+T\+A\+\_\+\+E\+R\+R\+OR\+: Compressed or uncompressed size of the Stream or size of the Index field would grow too big.
\item L\+Z\+M\+A\+\_\+\+P\+R\+O\+G\+\_\+\+E\+R\+R\+OR\+: Invalid arguments or this function is being used when \doxyref{lzma\+\_\+index\+\_\+hash\+\_\+decode()}{p.}{index__hash_8h_a891eb955284c9117155f92eb0ddba44c} has already been used. 
\end{DoxyItemize}
\end{DoxyReturn}


References hash\+\_\+append(), L\+Z\+M\+A\+\_\+\+P\+R\+O\+G\+\_\+\+E\+R\+R\+OR, L\+Z\+M\+A\+\_\+\+V\+L\+I\+\_\+\+M\+AX, return\+\_\+if\+\_\+error, lzma\+\_\+index\+\_\+hash\+\_\+s\+::uncompressed\+\_\+size, and lzma\+\_\+index\+\_\+hash\+\_\+s\+::unpadded\+\_\+size.

\mbox{\label{index__hash_8c_aedf75aefbcc0b3263898afbb9cab3ef5}} 
\index{index\+\_\+hash.\+c@{index\+\_\+hash.\+c}!lzma\+\_\+index\+\_\+hash\+\_\+decode@{lzma\+\_\+index\+\_\+hash\+\_\+decode}}
\index{lzma\+\_\+index\+\_\+hash\+\_\+decode@{lzma\+\_\+index\+\_\+hash\+\_\+decode}!index\+\_\+hash.\+c@{index\+\_\+hash.\+c}}
\subsubsection{lzma\+\_\+index\+\_\+hash\+\_\+decode()}
{\footnotesize\ttfamily \textbf{ lzma\+\_\+ret} lzma\+\_\+index\+\_\+hash\+\_\+decode (\begin{DoxyParamCaption}\item[{\textbf{ lzma\+\_\+index\+\_\+hash} $\ast$}]{index\+\_\+hash,  }\item[{const uint8\+\_\+t $\ast$}]{in,  }\item[{size\+\_\+t $\ast$}]{in\+\_\+pos,  }\item[{size\+\_\+t}]{in\+\_\+size }\end{DoxyParamCaption})}



Decode and validate the Index field. 

After telling the sizes of all Blocks with \doxyref{lzma\+\_\+index\+\_\+hash\+\_\+append()}{p.}{index__hash_8h_a2bdbe4f0b5fa2fadb7528447feaaa97f}, the actual Index field is decoded with this function. Specifically, once decoding of the Index field has been started, no more Records can be added using \doxyref{lzma\+\_\+index\+\_\+hash\+\_\+append()}{p.}{index__hash_8h_a2bdbe4f0b5fa2fadb7528447feaaa97f}.

This function doesn\textquotesingle{}t use \doxyref{lzma\+\_\+stream}{p.}{structlzma__stream} structure to pass the input data. Instead, the input buffer is specified using three arguments. This is because it matches better the internal A\+P\+Is of liblzma.


\begin{DoxyParams}{Parameters}
{\em index\+\_\+hash} & Pointer to a lzma\+\_\+index\+\_\+hash structure \\
\hline
{\em in} & Pointer to the beginning of the input buffer \\
\hline
{\em in\+\_\+pos} & in[$\ast$in\+\_\+pos] is the next byte to process \\
\hline
{\em in\+\_\+size} & in[in\+\_\+size] is the first byte not to process\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
-\/ L\+Z\+M\+A\+\_\+\+OK\+: So far good, but more input is needed.
\begin{DoxyItemize}
\item L\+Z\+M\+A\+\_\+\+S\+T\+R\+E\+A\+M\+\_\+\+E\+ND\+: Index decoded successfully and it matches the Records given with \doxyref{lzma\+\_\+index\+\_\+hash\+\_\+append()}{p.}{index__hash_8h_a2bdbe4f0b5fa2fadb7528447feaaa97f}.
\item L\+Z\+M\+A\+\_\+\+D\+A\+T\+A\+\_\+\+E\+R\+R\+OR\+: Index is corrupt or doesn\textquotesingle{}t match the information given with \doxyref{lzma\+\_\+index\+\_\+hash\+\_\+append()}{p.}{index__hash_8h_a2bdbe4f0b5fa2fadb7528447feaaa97f}.
\item L\+Z\+M\+A\+\_\+\+B\+U\+F\+\_\+\+E\+R\+R\+OR\+: Cannot progress because $\ast$in\+\_\+pos $>$= in\+\_\+size.
\item L\+Z\+M\+A\+\_\+\+P\+R\+O\+G\+\_\+\+E\+R\+R\+OR 
\end{DoxyItemize}
\end{DoxyReturn}


References hash\+\_\+append(), L\+Z\+M\+A\+\_\+\+B\+U\+F\+\_\+\+E\+R\+R\+OR, lzma\+\_\+check\+\_\+finish(), lzma\+\_\+check\+\_\+size(), lzma\+\_\+crc32(), L\+Z\+M\+A\+\_\+\+D\+A\+T\+A\+\_\+\+E\+R\+R\+OR, L\+Z\+M\+A\+\_\+\+OK, L\+Z\+M\+A\+\_\+\+S\+T\+R\+E\+A\+M\+\_\+\+E\+ND, L\+Z\+M\+A\+\_\+\+V\+L\+I\+\_\+C, lzma\+\_\+vli\+\_\+decode(), and return\+\_\+if\+\_\+error.

