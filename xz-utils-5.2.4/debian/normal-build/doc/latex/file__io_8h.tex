\section{xz/file\+\_\+io.h File Reference}
\label{file__io_8h}\index{xz/file\+\_\+io.\+h@{xz/file\+\_\+io.\+h}}


I/O types and functions.  


\subsection*{Data Structures}
\begin{DoxyCompactItemize}
\item 
union \textbf{ io\+\_\+buf}
\item 
struct \textbf{ file\+\_\+pair}
\end{DoxyCompactItemize}
\subsection*{Macros}
\begin{DoxyCompactItemize}
\item 
\mbox{\label{file__io_8h_abe5d3c90538920357e5f36e108e5dcaa}} 
\#define {\bfseries I\+O\+\_\+\+B\+U\+F\+F\+E\+R\+\_\+\+S\+I\+ZE}~8192
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
void \textbf{ io\+\_\+init} (void)
\begin{DoxyCompactList}\small\item\em Initialize the I/O module. \end{DoxyCompactList}\item 
void \textbf{ io\+\_\+write\+\_\+to\+\_\+user\+\_\+abort\+\_\+pipe} (void)
\begin{DoxyCompactList}\small\item\em Write a byte to user\+\_\+abort\+\_\+pipe[1]. \end{DoxyCompactList}\item 
void \textbf{ io\+\_\+no\+\_\+sparse} (void)
\begin{DoxyCompactList}\small\item\em Disable creation of sparse files when decompressing. \end{DoxyCompactList}\item 
\textbf{ file\+\_\+pair} $\ast$ \textbf{ io\+\_\+open\+\_\+src} (const char $\ast$src\+\_\+name)
\begin{DoxyCompactList}\small\item\em Open the source file. \end{DoxyCompactList}\item 
bool \textbf{ io\+\_\+open\+\_\+dest} (\textbf{ file\+\_\+pair} $\ast$pair)
\begin{DoxyCompactList}\small\item\em Open the destination file. \end{DoxyCompactList}\item 
void \textbf{ io\+\_\+close} (\textbf{ file\+\_\+pair} $\ast$pair, bool success)
\begin{DoxyCompactList}\small\item\em Closes the file descriptors and frees possible allocated memory. \end{DoxyCompactList}\item 
size\+\_\+t \textbf{ io\+\_\+read} (\textbf{ file\+\_\+pair} $\ast$pair, \textbf{ io\+\_\+buf} $\ast$buf, size\+\_\+t size)
\begin{DoxyCompactList}\small\item\em Reads from the source file to a buffer. \end{DoxyCompactList}\item 
void \textbf{ io\+\_\+fix\+\_\+src\+\_\+pos} (\textbf{ file\+\_\+pair} $\ast$pair, size\+\_\+t rewind\+\_\+size)
\begin{DoxyCompactList}\small\item\em Fix the position in src\+\_\+fd. \end{DoxyCompactList}\item 
bool \textbf{ io\+\_\+pread} (\textbf{ file\+\_\+pair} $\ast$pair, \textbf{ io\+\_\+buf} $\ast$buf, size\+\_\+t size, off\+\_\+t pos)
\begin{DoxyCompactList}\small\item\em Read from source file from given offset to a buffer. \end{DoxyCompactList}\item 
bool \textbf{ io\+\_\+write} (\textbf{ file\+\_\+pair} $\ast$pair, const \textbf{ io\+\_\+buf} $\ast$buf, size\+\_\+t size)
\begin{DoxyCompactList}\small\item\em Writes a buffer to the destination file. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
I/O types and functions. 



\subsection{Function Documentation}
\mbox{\label{file__io_8h_a43bba613ce0efd6af387cd04458ede8d}} 
\index{file\+\_\+io.\+h@{file\+\_\+io.\+h}!io\+\_\+init@{io\+\_\+init}}
\index{io\+\_\+init@{io\+\_\+init}!file\+\_\+io.\+h@{file\+\_\+io.\+h}}
\subsubsection{io\+\_\+init()}
{\footnotesize\ttfamily void io\+\_\+init (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Initialize the I/O module. 

\mbox{\label{file__io_8h_a3e78657470e4fe9cc6755931b07f9f93}} 
\index{file\+\_\+io.\+h@{file\+\_\+io.\+h}!io\+\_\+write\+\_\+to\+\_\+user\+\_\+abort\+\_\+pipe@{io\+\_\+write\+\_\+to\+\_\+user\+\_\+abort\+\_\+pipe}}
\index{io\+\_\+write\+\_\+to\+\_\+user\+\_\+abort\+\_\+pipe@{io\+\_\+write\+\_\+to\+\_\+user\+\_\+abort\+\_\+pipe}!file\+\_\+io.\+h@{file\+\_\+io.\+h}}
\subsubsection{io\+\_\+write\+\_\+to\+\_\+user\+\_\+abort\+\_\+pipe()}
{\footnotesize\ttfamily void io\+\_\+write\+\_\+to\+\_\+user\+\_\+abort\+\_\+pipe (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Write a byte to user\+\_\+abort\+\_\+pipe[1]. 

This is called from a signal handler. \mbox{\label{file__io_8h_a26350b70a7ef7ae45e57f04157ade2aa}} 
\index{file\+\_\+io.\+h@{file\+\_\+io.\+h}!io\+\_\+no\+\_\+sparse@{io\+\_\+no\+\_\+sparse}}
\index{io\+\_\+no\+\_\+sparse@{io\+\_\+no\+\_\+sparse}!file\+\_\+io.\+h@{file\+\_\+io.\+h}}
\subsubsection{io\+\_\+no\+\_\+sparse()}
{\footnotesize\ttfamily void io\+\_\+no\+\_\+sparse (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Disable creation of sparse files when decompressing. 



References message(), try\+\_\+sparse, and V\+\_\+\+D\+E\+B\+UG.

\mbox{\label{file__io_8h_ac4fb03f340ee03676cbde913682a3719}} 
\index{file\+\_\+io.\+h@{file\+\_\+io.\+h}!io\+\_\+open\+\_\+src@{io\+\_\+open\+\_\+src}}
\index{io\+\_\+open\+\_\+src@{io\+\_\+open\+\_\+src}!file\+\_\+io.\+h@{file\+\_\+io.\+h}}
\subsubsection{io\+\_\+open\+\_\+src()}
{\footnotesize\ttfamily \textbf{ file\+\_\+pair}$\ast$ io\+\_\+open\+\_\+src (\begin{DoxyParamCaption}\item[{const char $\ast$}]{src\+\_\+name }\end{DoxyParamCaption})}



Open the source file. 



References io\+\_\+open\+\_\+src\+\_\+real(), is\+\_\+empty\+\_\+filename(), signals\+\_\+block(), signals\+\_\+unblock(), file\+\_\+pair\+::src\+\_\+fd, and file\+\_\+pair\+::src\+\_\+name.



Referenced by coder\+\_\+run().

\mbox{\label{file__io_8h_a51c7b0ad8b7829773a69972565b7d08d}} 
\index{file\+\_\+io.\+h@{file\+\_\+io.\+h}!io\+\_\+open\+\_\+dest@{io\+\_\+open\+\_\+dest}}
\index{io\+\_\+open\+\_\+dest@{io\+\_\+open\+\_\+dest}!file\+\_\+io.\+h@{file\+\_\+io.\+h}}
\subsubsection{io\+\_\+open\+\_\+dest()}
{\footnotesize\ttfamily bool io\+\_\+open\+\_\+dest (\begin{DoxyParamCaption}\item[{\textbf{ file\+\_\+pair} $\ast$}]{pair }\end{DoxyParamCaption})}



Open the destination file. 



References signals\+\_\+block().

\mbox{\label{file__io_8h_a8dcc56461111f392398385820ad9c1d9}} 
\index{file\+\_\+io.\+h@{file\+\_\+io.\+h}!io\+\_\+close@{io\+\_\+close}}
\index{io\+\_\+close@{io\+\_\+close}!file\+\_\+io.\+h@{file\+\_\+io.\+h}}
\subsubsection{io\+\_\+close()}
{\footnotesize\ttfamily void io\+\_\+close (\begin{DoxyParamCaption}\item[{\textbf{ file\+\_\+pair} $\ast$}]{pair,  }\item[{bool}]{success }\end{DoxyParamCaption})}



Closes the file descriptors and frees possible allocated memory. 

The success argument determines if source or destination file gets unlinked\+:
\begin{DoxyItemize}
\item false\+: The destination file is unlinked.
\item true\+: The source file is unlinked unless writing to stdout or --keep was used. 
\end{DoxyItemize}

References file\+\_\+pair\+::dest\+\_\+fd, file\+\_\+pair\+::dest\+\_\+pending\+\_\+sparse, file\+\_\+pair\+::dest\+\_\+try\+\_\+sparse, and message\+\_\+error().

\mbox{\label{file__io_8h_aeda6fa2567b1b96603abbae64217e2f8}} 
\index{file\+\_\+io.\+h@{file\+\_\+io.\+h}!io\+\_\+read@{io\+\_\+read}}
\index{io\+\_\+read@{io\+\_\+read}!file\+\_\+io.\+h@{file\+\_\+io.\+h}}
\subsubsection{io\+\_\+read()}
{\footnotesize\ttfamily size\+\_\+t io\+\_\+read (\begin{DoxyParamCaption}\item[{\textbf{ file\+\_\+pair} $\ast$}]{pair,  }\item[{\textbf{ io\+\_\+buf} $\ast$}]{buf,  }\item[{size\+\_\+t}]{size }\end{DoxyParamCaption})}



Reads from the source file to a buffer. 


\begin{DoxyParams}{Parameters}
{\em pair} & File pair having the source file open for reading \\
\hline
{\em buf} & Destination buffer to hold the read data \\
\hline
{\em size} & Size of the buffer; assumed be smaller than S\+S\+I\+Z\+E\+\_\+\+M\+AX\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
On success, number of bytes read is returned. On end of file zero is returned and pair-\/$>$src\+\_\+eof set to true. On error, S\+I\+Z\+E\+\_\+\+M\+AX is returned and error message printed. 
\end{DoxyReturn}


Referenced by coder\+\_\+passthru().

\mbox{\label{file__io_8h_aa06dd4cd771d5a19bc191ff334f0623a}} 
\index{file\+\_\+io.\+h@{file\+\_\+io.\+h}!io\+\_\+fix\+\_\+src\+\_\+pos@{io\+\_\+fix\+\_\+src\+\_\+pos}}
\index{io\+\_\+fix\+\_\+src\+\_\+pos@{io\+\_\+fix\+\_\+src\+\_\+pos}!file\+\_\+io.\+h@{file\+\_\+io.\+h}}
\subsubsection{io\+\_\+fix\+\_\+src\+\_\+pos()}
{\footnotesize\ttfamily void io\+\_\+fix\+\_\+src\+\_\+pos (\begin{DoxyParamCaption}\item[{\textbf{ file\+\_\+pair} $\ast$}]{pair,  }\item[{size\+\_\+t}]{rewind\+\_\+size }\end{DoxyParamCaption})}



Fix the position in src\+\_\+fd. 

This is used when --single-\/thream has been specified and decompression is successful. If the input file descriptor supports seeking, this function fixes the input position to point to the next byte after the decompressed stream.


\begin{DoxyParams}{Parameters}
{\em pair} & File pair having the source file open for reading \\
\hline
{\em rewind\+\_\+size} & How many bytes of extra have been read i.\+e. how much to seek backwards. \\
\hline
\end{DoxyParams}
\mbox{\label{file__io_8h_af0781545c818796c48a4ee8dadd2c2a7}} 
\index{file\+\_\+io.\+h@{file\+\_\+io.\+h}!io\+\_\+pread@{io\+\_\+pread}}
\index{io\+\_\+pread@{io\+\_\+pread}!file\+\_\+io.\+h@{file\+\_\+io.\+h}}
\subsubsection{io\+\_\+pread()}
{\footnotesize\ttfamily bool io\+\_\+pread (\begin{DoxyParamCaption}\item[{\textbf{ file\+\_\+pair} $\ast$}]{pair,  }\item[{\textbf{ io\+\_\+buf} $\ast$}]{buf,  }\item[{size\+\_\+t}]{size,  }\item[{off\+\_\+t}]{pos }\end{DoxyParamCaption})}



Read from source file from given offset to a buffer. 

This is remotely similar to standard pread(). This uses lseek() though, so the read offset is changed on each call.


\begin{DoxyParams}{Parameters}
{\em pair} & Seekable source file \\
\hline
{\em buf} & Destination buffer \\
\hline
{\em size} & Amount of data to read \\
\hline
{\em pos} & Offset relative to the beginning of the file, from which the data should be read.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
On success, false is returned. On error, error message is printed and true is returned. 
\end{DoxyReturn}


References message\+\_\+error(), and file\+\_\+pair\+::src\+\_\+fd.



Referenced by parse\+\_\+check\+\_\+value().

\mbox{\label{file__io_8h_a42ccfb816386ca04e622762bad58ef6f}} 
\index{file\+\_\+io.\+h@{file\+\_\+io.\+h}!io\+\_\+write@{io\+\_\+write}}
\index{io\+\_\+write@{io\+\_\+write}!file\+\_\+io.\+h@{file\+\_\+io.\+h}}
\subsubsection{io\+\_\+write()}
{\footnotesize\ttfamily bool io\+\_\+write (\begin{DoxyParamCaption}\item[{\textbf{ file\+\_\+pair} $\ast$}]{pair,  }\item[{const \textbf{ io\+\_\+buf} $\ast$}]{buf,  }\item[{size\+\_\+t}]{size }\end{DoxyParamCaption})}



Writes a buffer to the destination file. 


\begin{DoxyParams}{Parameters}
{\em pair} & File pair having the destination file open for writing \\
\hline
{\em buf} & Buffer containing the data to be written \\
\hline
{\em size} & Size of the buffer; assumed be smaller than S\+S\+I\+Z\+E\+\_\+\+M\+AX\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
On success, zero is returned. On error, -\/1 is returned and error message printed. 
\end{DoxyReturn}


Referenced by coder\+\_\+passthru().

