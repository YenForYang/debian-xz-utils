<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>XZ Utils: liblzma/common/block_buffer_encoder.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">XZ Utils
   &#160;<span id="projectnumber">5.2.4</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_2e0898c272e1f0f93c8ef15f5da2a912.html">liblzma</a></li><li class="navelem"><a class="el" href="dir_db777975f8e21a5de5f283e04473bf67.html">common</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">block_buffer_encoder.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Single-call .xz Block encoder.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="block__buffer__encoder_8h.html">block_buffer_encoder.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="block__encoder_8h.html">block_encoder.h</a>&quot;</code><br />
<code>#include &quot;filter_encoder.h&quot;</code><br />
<code>#include &quot;<a class="el" href="lzma2__encoder_8h.html">lzma2_encoder.h</a>&quot;</code><br />
<code>#include &quot;check.h&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a6cf3bc89aed406bb48c785dca58ae9da"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="block__buffer__encoder_8c.html#a6cf3bc89aed406bb48c785dca58ae9da">HEADERS_BOUND</a></td></tr>
<tr class="separator:a6cf3bc89aed406bb48c785dca58ae9da"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a6898d0dc76ff4e030055ce346a6ef57a"><td class="memItemLeft" align="right" valign="top"><a id="a6898d0dc76ff4e030055ce346a6ef57a"></a>
static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>lzma2_bound</b> (uint64_t uncompressed_size)</td></tr>
<tr class="separator:a6898d0dc76ff4e030055ce346a6ef57a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fbb846b46ee307a065f86777ce8994e"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="block__buffer__encoder_8c.html#a1fbb846b46ee307a065f86777ce8994e">lzma_block_buffer_bound64</a> (uint64_t uncompressed_size)</td></tr>
<tr class="separator:a1fbb846b46ee307a065f86777ce8994e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcfe5ca83fac7bfbd1a0a7d41e32306d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="block__buffer__encoder_8c.html#afcfe5ca83fac7bfbd1a0a7d41e32306d">lzma_block_buffer_bound</a> (size_t uncompressed_size)</td></tr>
<tr class="memdesc:afcfe5ca83fac7bfbd1a0a7d41e32306d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate maximum output size for single-call Block encoding.  <a href="#afcfe5ca83fac7bfbd1a0a7d41e32306d">More...</a><br /></td></tr>
<tr class="separator:afcfe5ca83fac7bfbd1a0a7d41e32306d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5295d468fbf2da3a35f458c90b7966c5"><td class="memItemLeft" align="right" valign="top"><a id="a5295d468fbf2da3a35f458c90b7966c5"></a>
static <a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6e">lzma_ret</a>&#160;</td><td class="memItemRight" valign="bottom"><b>block_encode_uncompressed</b> (<a class="el" href="structlzma__block.html">lzma_block</a> *block, const uint8_t *in, size_t in_size, uint8_t *out, size_t *out_pos, size_t out_size)</td></tr>
<tr class="separator:a5295d468fbf2da3a35f458c90b7966c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c318709429c788b7d46a496bee07793"><td class="memItemLeft" align="right" valign="top"><a id="a9c318709429c788b7d46a496bee07793"></a>
static <a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6e">lzma_ret</a>&#160;</td><td class="memItemRight" valign="bottom"><b>block_encode_normal</b> (<a class="el" href="structlzma__block.html">lzma_block</a> *block, const <a class="el" href="structlzma__allocator.html">lzma_allocator</a> *allocator, const uint8_t *in, size_t in_size, uint8_t *out, size_t *out_pos, size_t out_size)</td></tr>
<tr class="separator:a9c318709429c788b7d46a496bee07793"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af47a9de6406a0ab2c8eb1f407a61eaae"><td class="memItemLeft" align="right" valign="top"><a id="af47a9de6406a0ab2c8eb1f407a61eaae"></a>
static <a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6e">lzma_ret</a>&#160;</td><td class="memItemRight" valign="bottom"><b>block_buffer_encode</b> (<a class="el" href="structlzma__block.html">lzma_block</a> *block, const <a class="el" href="structlzma__allocator.html">lzma_allocator</a> *allocator, const uint8_t *in, size_t in_size, uint8_t *out, size_t *out_pos, size_t out_size, bool try_to_compress)</td></tr>
<tr class="separator:af47a9de6406a0ab2c8eb1f407a61eaae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a037f3f6311573f0a8d16fb19fa634dcc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6e">lzma_ret</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="block__buffer__encoder_8c.html#a037f3f6311573f0a8d16fb19fa634dcc">lzma_block_buffer_encode</a> (<a class="el" href="structlzma__block.html">lzma_block</a> *block, const <a class="el" href="structlzma__allocator.html">lzma_allocator</a> *allocator, const uint8_t *in, size_t in_size, uint8_t *out, size_t *out_pos, size_t out_size)</td></tr>
<tr class="memdesc:a037f3f6311573f0a8d16fb19fa634dcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Single-call .xz Block encoder.  <a href="#a037f3f6311573f0a8d16fb19fa634dcc">More...</a><br /></td></tr>
<tr class="separator:a037f3f6311573f0a8d16fb19fa634dcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadd553cf24913d38342c9d5dda7d1d21"><td class="memItemLeft" align="right" valign="top"><a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6e">lzma_ret</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="block__buffer__encoder_8c.html#aadd553cf24913d38342c9d5dda7d1d21">lzma_block_uncomp_encode</a> (<a class="el" href="structlzma__block.html">lzma_block</a> *block, const uint8_t *in, size_t in_size, uint8_t *out, size_t *out_pos, size_t out_size)</td></tr>
<tr class="memdesc:aadd553cf24913d38342c9d5dda7d1d21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Single-call uncompressed .xz Block encoder.  <a href="#aadd553cf24913d38342c9d5dda7d1d21">More...</a><br /></td></tr>
<tr class="separator:aadd553cf24913d38342c9d5dda7d1d21"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Single-call .xz Block encoder. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a6cf3bc89aed406bb48c785dca58ae9da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cf3bc89aed406bb48c785dca58ae9da">&#9670;&nbsp;</a></span>HEADERS_BOUND</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define HEADERS_BOUND</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">((1 + 1 + 2 * <a class="code" href="vli_8h.html#a063ecff4133aa2f8899b9fa3fdefd310">LZMA_VLI_BYTES_MAX</a> + 3 + 4 \</div><div class="line">                + <a class="code" href="api_2lzma_2check_8h.html#a379e931cf86351ab1d97896cda9abbe0">LZMA_CHECK_SIZE_MAX</a> + 3) &amp; ~3)</div><div class="ttc" id="vli_8h_html_a063ecff4133aa2f8899b9fa3fdefd310"><div class="ttname"><a href="vli_8h.html#a063ecff4133aa2f8899b9fa3fdefd310">LZMA_VLI_BYTES_MAX</a></div><div class="ttdeci">#define LZMA_VLI_BYTES_MAX</div><div class="ttdoc">Maximum supported encoded length of variable length integers. </div><div class="ttdef"><b>Definition:</b> vli.h:44</div></div>
<div class="ttc" id="api_2lzma_2check_8h_html_a379e931cf86351ab1d97896cda9abbe0"><div class="ttname"><a href="api_2lzma_2check_8h.html#a379e931cf86351ab1d97896cda9abbe0">LZMA_CHECK_SIZE_MAX</a></div><div class="ttdeci">#define LZMA_CHECK_SIZE_MAX</div><div class="ttdoc">Maximum size of a Check field. </div><div class="ttdef"><b>Definition:</b> check.h:102</div></div>
</div><!-- fragment --><p>Estimate the maximum size of the Block Header and Check fields for a Block that uses LZMA2 uncompressed chunks. We could use <a class="el" href="block_8h.html#ae9b47abc872d0b02c2da9d3fa5a7dacd" title="Calculate Block Header Size. ">lzma_block_header_size()</a> but this is simpler.</p>
<p>Block Header Size + Block Flags + Compressed Size</p><ul>
<li>Uncompressed Size + Filter Flags for LZMA2 + CRC32 + Check and round up to the next multiple of four to take Header Padding into account. </li>
</ul>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a1fbb846b46ee307a065f86777ce8994e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fbb846b46ee307a065f86777ce8994e">&#9670;&nbsp;</a></span>lzma_block_buffer_bound64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t lzma_block_buffer_bound64 </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>uncompressed_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>uint64_t version of <a class="el" href="block_8h.html#a58ff73e2572b529f48cc590bfffe5b4f" title="Calculate maximum output size for single-call Block encoding. ">lzma_block_buffer_bound()</a>. It is used by <a class="el" href="stream__encoder__mt_8c.html" title="Multithreaded .xz Stream encoder. ">stream_encoder_mt.c</a>. Probably the original <a class="el" href="block_8h.html#a58ff73e2572b529f48cc590bfffe5b4f" title="Calculate maximum output size for single-call Block encoding. ">lzma_block_buffer_bound()</a> should have been 64-bit, but fixing it would break the ABI. </p>

</div>
</div>
<a id="afcfe5ca83fac7bfbd1a0a7d41e32306d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcfe5ca83fac7bfbd1a0a7d41e32306d">&#9670;&nbsp;</a></span>lzma_block_buffer_bound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t lzma_block_buffer_bound </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>uncompressed_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate maximum output size for single-call Block encoding. </p>
<p>This is equivalent to <a class="el" href="container_8h.html#a66d4366a47b8332bff2a512f44f5c45e" title="Calculate output buffer size for single-call Stream encoder. ">lzma_stream_buffer_bound()</a> but for .xz Blocks. See the documentation of <a class="el" href="container_8h.html#a66d4366a47b8332bff2a512f44f5c45e" title="Calculate output buffer size for single-call Stream encoder. ">lzma_stream_buffer_bound()</a>. </p>

</div>
</div>
<a id="a037f3f6311573f0a8d16fb19fa634dcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a037f3f6311573f0a8d16fb19fa634dcc">&#9670;&nbsp;</a></span>lzma_block_buffer_encode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6e">lzma_ret</a> lzma_block_buffer_encode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlzma__block.html">lzma_block</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structlzma__allocator.html">lzma_allocator</a> *&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>in_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>out_pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>out_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Single-call .xz Block encoder. </p>
<p>In contrast to the multi-call encoder initialized with <a class="el" href="block_8h.html#a2218a49025a0b44f9a6f9d6d24359359" title="Initialize .xz Block encoder. ">lzma_block_encoder()</a>, this function encodes also the Block Header. This is required to make it possible to write appropriate Block Header also in case the data isn't compressible, and different filter chain has to be used to encode the data in uncompressed form using uncompressed chunks of the LZMA2 filter.</p>
<p>When the data isn't compressible, header_size, compressed_size, and uncompressed_size are set just like when the data was compressible, but it is possible that header_size is too small to hold the filter chain specified in block-&gt;filters, because that isn't necessarily the filter chain that was actually used to encode the data. <a class="el" href="block_8h.html#a412d5605280fa29befae1b89e344bf30" title="Calculate Unpadded Size. ">lzma_block_unpadded_size()</a> still works normally, because it doesn't read the filters array.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>Block options: block-&gt;version, block-&gt;check, and block-&gt;filters must have been initialized. </td></tr>
    <tr><td class="paramname">allocator</td><td><a class="el" href="structlzma__allocator.html" title="Custom functions for memory handling. ">lzma_allocator</a> for custom allocator functions. Set to NULL to use malloc() and free(). </td></tr>
    <tr><td class="paramname">in</td><td>Beginning of the input buffer </td></tr>
    <tr><td class="paramname">in_size</td><td>Size of the input buffer </td></tr>
    <tr><td class="paramname">out</td><td>Beginning of the output buffer </td></tr>
    <tr><td class="paramname">out_pos</td><td>The next byte will be written to out[*out_pos]. *out_pos is updated only if encoding succeeds. </td></tr>
    <tr><td class="paramname">out_size</td><td>Size of the out buffer; the first byte into which no data is written to is out[out_size].</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>- LZMA_OK: Encoding was successful.<ul>
<li>LZMA_BUF_ERROR: Not enough output buffer space.</li>
<li>LZMA_UNSUPPORTED_CHECK</li>
<li>LZMA_OPTIONS_ERROR</li>
<li>LZMA_MEM_ERROR</li>
<li>LZMA_DATA_ERROR</li>
<li>LZMA_PROG_ERROR </li>
</ul>
</dd></dl>

</div>
</div>
<a id="aadd553cf24913d38342c9d5dda7d1d21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadd553cf24913d38342c9d5dda7d1d21">&#9670;&nbsp;</a></span>lzma_block_uncomp_encode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6e">lzma_ret</a> lzma_block_uncomp_encode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlzma__block.html">lzma_block</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>in_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>out_pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>out_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Single-call uncompressed .xz Block encoder. </p>
<p>This is like <a class="el" href="block_8h.html#af415fa5130ab64e8760e9c39e856fa54" title="Single-call .xz Block encoder. ">lzma_block_buffer_encode()</a> except this doesn't try to compress the data and instead encodes the data using LZMA2 uncompressed chunks. The required output buffer size can be determined with <a class="el" href="block_8h.html#a58ff73e2572b529f48cc590bfffe5b4f" title="Calculate maximum output size for single-call Block encoding. ">lzma_block_buffer_bound()</a>.</p>
<p>Since the data won't be compressed, this function ignores block-&gt;filters. This function doesn't take <a class="el" href="structlzma__allocator.html" title="Custom functions for memory handling. ">lzma_allocator</a> because this function doesn't allocate any memory from the heap. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
